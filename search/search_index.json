{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documenta\u00e7\u00e3o do Tamboerijn","text":"<p>Disclaimer: This docs are based on the original documentation written by the HULKs team, it has some parts adapted to our team's needs</p> <p></p>"},{"location":"#sobre","title":"Sobre","text":"<p>Este resposit\u00f3rio tem como objetivo documentar o codebase Tamboerijn, que consiste na adapta\u00e7\u00e3o do code realease da equipe alem\u00e3 HULKs. Ele cont\u00e9m partes traduzidas do ingl\u00eas para o portugu\u00eas, al\u00e9m de algumas adapta\u00e7\u00f5es feitas pela equipe para suprir nossos interesses e necessidades internas.</p> <p>Ele est\u00e1 sob a licensa GPU 3.0, que pode ser encontrada aqui, assim como o reposit\u00f3rio original da equipe HULKs, que pode ser encontrado aqui.</p> <p>Todas as pastas abordam um t\u00f3pico espec\u00edfico do codebase, e cont\u00e9m um arquivo <code>README.md</code> com informa\u00e7\u00f5es sobre o t\u00f3pico.</p> <p>\u00c9 uma boa pr\u00e1tica que todos os membros da categoria leiam este documento para entender o funcionamento do codebase, assim como atualizar este documento conforme novas atualiza\u00e7\u00f5es forem sendo implementadas.</p> <p>Qualquer d\u00favida sobre o funcionamento do codebase pode ser tirada com os membros da equipe, ou deixando uma issue do reposit\u00f3rio oficial. Qualquer problema com a tradu\u00e7\u00e3o, adapta\u00e7\u00e3o ou reda\u00e7\u00e3o do documento pode ser reportado diretamente neste reposit\u00f3rio.</p>"},{"location":"#indice-e-status","title":"\u00cdndice e Status","text":"T\u00f3pico Status Configura\u00e7\u00e3o do Projeto Incompleto Framework Incompleto Ferramental Incompleto Sistema Operacional Incompleto Rob\u00f3tica N\u00e3o existe Workflow Incompleto"},{"location":"config-projeto/","title":"Sobre","text":"<p>Essa se\u00e7\u00e3o descreve os passos necess\u00e1rios para baixar o c\u00f3digo, compilar para o simulador Webots, como preparar o NAO SDK (toolchain) e a imagem do sistema usando Yocto e finalmente como compilar e enviar o c\u00f3digo para o rob\u00f4.</p> <p>A ordem ideal para se seguir a documenta\u00e7\u00e3o \u00e9:     1. <code>README.md</code>     2. <code>config-git.md</code>     3. <code>config-projeto.md</code>     4. <code>imagem-sdk.md</code>     5. <code>config-nao.md</code>     6. <code>documentacao.md</code></p>"},{"location":"config-projeto/config-git/","title":"Configurando o Git","text":"<p>Caso voc\u00ea n\u00e3o tenha configurado seu Git ainda.</p>"},{"location":"config-projeto/config-git/#configurando-username-e-email","title":"Configurando Username e Email","text":"<p>A primeira coisa que voc\u00ea deve fazer ao instalar o Git \u00e9 configurar seu nome de usu\u00e1rio e email. Isso \u00e9 importante para que o Git saiba quem est\u00e1 fazendo as altera\u00e7\u00f5es no c\u00f3digo ao gerar o commit.</p> <p><pre><code>git config --global user.name \"Seu Nome\"\ngit config --global user.email \"Seu Email\"\n</code></pre> Ideal que utilize seu email institucional ou o fornecido \u00e0 Rinobot.</p>"},{"location":"config-projeto/config-git/#criando-e-adicionando-a-ssh-key","title":"Criando e adicionando a SSH-Key","text":"<p>Desde 2023, o Github n\u00e3o aceita mais autentica\u00e7\u00e3o por senha, ent\u00e3o \u00e9 necess\u00e1rio criar uma chave SSH (Secure Shell Protocol) para autentica\u00e7\u00e3o. Voc\u00ea pode seguir o tutorial oficial do Github aqui. Caso j\u00e1 tenha essa parte configurada, voc\u00ea pode pular para o pr\u00f3ximo passo. Qualquer d\u00favida, entre em contato com a equipe.</p>"},{"location":"config-projeto/config-nao/","title":"Configura\u00e7\u00f5es do NAO","text":"<p>Essa se\u00e7\u00e3o assume que voc\u00ea j\u00e1 tenha seguido todos os passos anteriores. Caso n\u00e3o tenha, siga a documenta\u00e7\u00e3o na ordem correta.</p>"},{"location":"config-projeto/config-nao/#flashando-o-firmware","title":"Flashando o firmware","text":"<p>Voc\u00ea pode fazer o flash do firmware tanto usando o <code>pepsi</code> quanto manualmente utilizando um pendrive.</p> <p>Para fazer com o <code>pepsi</code> \u00e9 necess\u00e1rio utilizar o subcomando <code>gammaray</code>, isto \u00e9 descrito na se\u00e7\u00e3o de ferramental. </p>"},{"location":"config-projeto/config-nao/#preparando-o-pendrive","title":"Preparando o pendrive","text":"<p>Primeiro, a imagem do firmware tem que ser copiada para o pendrive. Use o comando <code>lsblk</code> para verificar o nome do dispositivo.</p> <p>Depois, utilize o seguinte comando para copiar a imagem para o pendrive, substitua <code>/path-to-image.opn</code> pelo caminho da imagem e <code>sdX</code> pelo dispositivo do pendrive: <pre><code>    dd if=/path-to-image.opn of=/dev/sdX status=progress\n</code></pre></p> <p>Finalmente, rode o comando <code>sync</code> para garantir que todos os dados foram escritos no pendrive antes de remov\u00ea-lo. <pre><code>    sync\n</code></pre></p>"},{"location":"config-projeto/config-nao/#flashando-a-imagem-no-nao","title":"Flashando a imagem no NAO","text":"<pre><code>- Certifique-se de que o NAO est\u00e1 desligado e ligado na tomada para prevenir que a bateria acabe durante o processo. Se a bateria acabar, o NAO pode se tornar um peso de papel de 70 mil reais.\n- Insira o pendrive no NAO na porta USB localizada na nuca do rob\u00f4.\n- Segure o bot\u00e3o de ligar por 5 segundos at\u00e9 que a luz acenda, e solta imediatamente. Os LEDs do bot\u00e3o devem piscar rapidamente.\n- Espere o processo terminar. O NAO ir\u00e1 reiniciar automaticamente quando terminar.\n- As luzes das orelhas do NAO ir\u00e3o acender indicando uma barra de progresso.\n- Pode ser necess\u00e1rio reiniciar o NAO manualmente ap\u00f3s o processo terminar. Caso ocorra, retire o pendrive antes de ligar o NAO.\n</code></pre>"},{"location":"config-projeto/config-nao/#compilando-para-o-nao","title":"Compilando para o NAO","text":"<p>O comando para compilar o c\u00f3digo para o NAO \u00e9 o mesmo que para o simulador, apenas com a flag <code>--target nao</code> adicionada. O comando \u00e9: <pre><code>    ./pepsi build --target nao\n</code></pre> A compila\u00e7\u00e3o utiliza o perfil <code>incremental</code> do cargo por padr\u00e3o.</p>"},{"location":"config-projeto/config-nao/#upload-para-o-robo","title":"Upload para o rob\u00f4","text":"<p>O upload pode ser feito com o n\u00famero ou IPs do rob\u00f4. O comando \u00e9: <pre><code>    ./pepsi upload &lt;numero/IP&gt;\n</code></pre> Ele ir\u00e1 compilar o c\u00f3digo e enviar para o rob\u00f4 especificado automaticamente.</p>"},{"location":"config-projeto/config-nao/#acesso-remoto","title":"Acesso remoto","text":"<p>\u00c9 poss\u00edvel conectar ao shell do NAO via SSH utilizando o comando: <pre><code>    ./pepsi shell &lt;numero/IP&gt;\n</code></pre></p>"},{"location":"config-projeto/config-opencv/","title":"Como instalar OpenCV","text":"<p>O OpenCV \u00e9 uma biblioteca de vis\u00e3o computacional usada eventualmente por algumas equipes da SPL.</p>"},{"location":"config-projeto/config-opencv/#alguns-usos-da-biblioteca-na-liga","title":"Alguns usos da biblioteca na liga:","text":"<ol> <li>SPQRTeam \ud83c\uddee\ud83c\uddf9 (2016):</li> <li>Github</li> <li>Tutorial de detec\u00e7\u00e3o de bola usando Haar Cascade</li> <li>Dutch Nao Team \ud83c\uddf3\ud83c\uddf1 (2021):</li> <li>YOLO v3 (artigo)</li> </ol>"},{"location":"config-projeto/config-opencv/#como-instalar","title":"Como instalar","text":"<p>A maneira \"padr\u00e3o\" de instala\u00e7\u00e3o do OpenCV \u00e9 via compila\u00e7\u00e3o do c\u00f3digo fonte. Por ser um processo relativamente complicado, um querido fez um script que faz esse processo. 1. Crie uma pasta em qualquer lugar (e.g opencv_installation) 2. Baixe esse Makefile. <sub>link reserva</sub> 3. Coloque o Makefile na pasta que voc\u00ea criou 4. dentro da pasta: <code>make install</code></p> Exemplo de instala\u00e7\u00e3o via terminal <pre><code>sudo apt install -y build-essential\nmkdir opencv_install\ncd opencv_install\nwget \"https://github.com/rinobot-team/SPL-assets/raw/main/OpenCV4/Makefile\"\nmake install\n</code></pre>"},{"location":"config-projeto/config-opencv/#detalhes","title":"Detalhes","text":"<ol> <li>Caso n\u00e3o tenha o <code>make</code>: <code>sudo apt install build-essential</code></li> <li>Vai dar um erro no final do script, algo como:</li> </ol> Mostrar erro do final do script    ```bash     go clean --cache     rm -rf /tmp/opencv     /bin/sh: 1: go: not found     go run ./cmd/version/main.go     make: go: No such file or directory     make: *** [Makefile:315: verify] Error 127 ```  <p>N\u00e3o se preocupe.</p>"},{"location":"config-projeto/config-opencv/#como-testar-a-instalacao","title":"Como testar a instala\u00e7\u00e3o","text":"<p><code>TODO</code></p>"},{"location":"config-projeto/config-projeto/","title":"Configura\u00e7\u00f5es do Projeto e Compila\u00e7\u00e3o para o Simulador Webots","text":"<p>Esse t\u00f3pico vai gui\u00e1-los na instala\u00e7\u00e3o de depend\u00eancias e configura\u00e7\u00f5es necess\u00e1rias para compilar o c\u00f3digo do projeto para o simulador Webots. A Rinobot recomenda utilizar o sistema operacional Ubuntu 20.04 LTS para o desenvolvimento do projeto, por\u00e9m Arch Linux e derivados tamb\u00e9m s\u00e3o suportados.</p>"},{"location":"config-projeto/config-projeto/#instalando-dependencias","title":"Instalando depend\u00eancias","text":"<p>Alguns pacotes s\u00e3o necess\u00e1rios para compilar o c\u00f3digo do projeto. Para instal\u00e1-los, execute o comando abaixo:</p> Ubuntu 20.04 LTS <ol> <li>Instalando Depend\u00eancias <pre><code>    sudo apt update  \n    sudo apt install git git-lfs build-essential libssl-dev pkg-config libclang-dev rsync cmake libhdf5-dev libopusfile-dev python3 libasound2-dev libluajit-5.1-dev libudev-dev\n</code></pre></li> <li> <p>Instalando Webots Baixe o Webots aqui e a partir do arquivo XXX.deb instale com <pre><code>    sudo dpkg -i XXX.deb\n</code></pre></p> </li> <li> <p>Instale a toolchain do Rust <pre><code>    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre></p> </li> </ol> Arch, Manjaro e derivados <ol> <li> <p>Instalando Depend\u00eancias <pre><code>    yay -S git git-lfs base-devel rustup rsync cmake clang hdf5 opusfile python webots\n</code></pre> Para o Arch recomendamos usar o AUR Helper <code>yay</code>, caso n\u00e3o tenha, instale com <code>sudo pacman -S yay</code>.</p> </li> <li> <p>Instale a toolchain do Rust <pre><code>    rustup default stable\n</code></pre></p> </li> </ol>"},{"location":"config-projeto/config-projeto/#adiquirindo-o-codigo","title":"Adiquirindo o c\u00f3digo","text":"<p>Clone o reposit\u00f3rio do projeto e entre na pasta do projeto: <pre><code>    git clone git@github.com:rinobot-team/Tamboerijn.git\n    cd Tamboerijn\n</code></pre> Recomendamos clonar o reposit\u00f3rio com SSH, caso n\u00e3o tenha a chave SSH configurada, clone com HTTPS: <pre><code>    git clone https://github.com/rinobot-team/Tamboerijn.git\n    cd Tamboerijn\n</code></pre></p>"},{"location":"config-projeto/config-projeto/#webots","title":"Webots","text":"<p>Na Rinobot ainda n\u00e3o aderimos 100% ao Webots, por\u00e9m planejamos migrar para ele em breve para simula\u00e7\u00e3o do comportamento, estrat\u00e9gia e resposta ao GameController. Mas, seguindo a documenta\u00e7\u00e3o original da HULKs temos os seguintes passos:</p>"},{"location":"config-projeto/config-projeto/#compilando-para-o-webots","title":"Compilando para o Webots","text":"<p>Na ra\u00edz do nosso reposit\u00f3rio h\u00e1 um programa chamado <code>pepsi</code>, ele \u00e9 uma multiferramenta que usamos para compila\u00e7\u00e3o e upload para o rob\u00f4. Para compilar o projeto para o Webots, execute o comando abaixo: <pre><code>    ./pepsi build\n</code></pre> Caso seja a primeira vez que esteja utilizando o comando, ele primeiro ir\u00e1 compilar a ferramenta e depois compilar o projeto. Isso pode demorar alguns minutos.</p>"},{"location":"config-projeto/config-projeto/#rodando-o-simulaor","title":"Rodando o simulaor","text":"<p>Depois de compilado, abre o Webots e abra o arquivo <code>webots/worlds/penalized.wbt</code> do reposit\u00f3rio.</p>"},{"location":"config-projeto/config-projeto/#rodando-no-modo-externo","title":"Rodando no modo externo","text":"<p>Para n\u00e3o ser obrigado a reabrir o programa toda que recompilar o controlador voc\u00ea pode rodar o <code>webots/worlds/penalized_extern.wbt</code> e iniciar o controlador com o seguinte comando: <pre><code>    ./pepsi run\n</code></pre></p>"},{"location":"config-projeto/documentacao/","title":"Documenta\u00e7\u00e3o","text":"<p>Este documento visa descrever como documentar corretamente o projeto e o workflow de desenvolvimento. Assim como um resumo de produ\u00e7\u00e3o com Markdown e configura\u00e7\u00f5es do projeto e gera\u00e7\u00e3o do site.</p> <p>Qualquer d\u00favida, problema na configura\u00e7\u00e3o, corre\u00e7\u00e3o ou sugest\u00e3o de melhoria, entre em contato com o gerente da categoria ou abra uma issue no reposit\u00f3rio.</p>"},{"location":"config-projeto/documentacao/#markdown","title":"Markdown","text":"<p>Markdown \u00e9 uma linguagem de marca\u00e7\u00e3o que permite a escrita de textos com formata\u00e7\u00e3o simples e r\u00e1pida. \u00c9 amplamente utilizada em documenta\u00e7\u00f5es de projetos, READMEs, wikis, entre outros. A linguagem \u00e9 simples e f\u00e1cil de aprender, e permite a escrita de textos com formata\u00e7\u00e3o b\u00e1sica, como t\u00edtulos, listas, links, imagens, tabelas, entre outros:</p> <p><pre><code># Titulo 1\n## Titulo 2\n### Titulo 3\n\nnegrito: **negrito**\nit\u00e1lico: *it\u00e1lico*\n\nlinha de c\u00f3digo: `c\u00f3digo`\nbloco de c\u00f3digo:\n    ```rust\n    fn main() {\n        println!(\"Hello, tamboerijn!\");\n    }\n    ```\n\u00c9 poss\u00edvel escolher a linguagem para melhor formata\u00e7\u00e3o do bloco de c\u00f3digo.\n\nLista n\u00e3o ordenada:\n- item 1\n- item 2\n- item 3\n\nLista ordenada:\n1. item 1\n2. item 2\n3. item 3\n\nLink: [Colinha de markdown](https://www.markdownguide.org/cheat-sheet/)\n</code></pre> Algumas conven\u00e7\u00f5es de formata\u00e7\u00e3o de texto s\u00e3o:    </p> <ul> <li>Utilizar somente um <code># Titulo</code> por arquivo.  </li> <li>Adicionar dois espa\u00e7os no final de uma linha para quebra de linha.  </li> <li>Utilizar <code>---</code> para separar se\u00e7\u00f5es, ou assuntos diferentes.  </li> <li>Comandos ou estruturas de diret\u00f3rios devem ser escritos como <code>c\u00f3digo</code>.  </li> <li>Separar texto de t\u00f3picos com uma linha em branco.  </li> </ul> <p>Informa\u00e7\u00f5es mais detalhadas sobre a linguagem Markdown podem ser encontradas no Cheat-Sheet.  </p>"},{"location":"config-projeto/documentacao/#configuracao","title":"Configura\u00e7\u00e3o","text":""},{"location":"config-projeto/documentacao/#git","title":"Git","text":"<p>\u00c9 ideal que os reposit\u00f3rios sejam clonados por SSH, j\u00e1 tendo a chave SSH configurada no GitHub, como feito anteriomente. Isso facilita o processo de clonagem e push de arquivos.</p> <p><pre><code>    git clone git@github.com:rinobot-team/SPL-Docs.git\n</code></pre> Caso haja algum problema de permiss\u00e3o entre em contato com o gerente da categoria ou diretor de projetos.</p> <p>O reposit\u00f3rio \u00e9 dividido em 3 branchs principais: - <code>main</code>: branch principal, onde o c\u00f3digo est\u00e1vel \u00e9 mantido. - <code>dev</code>: branch de desenvolvimento, onde as novas documenta\u00e7\u00f5es s\u00e3o escritas e revisadas. - <code>gh-pages</code>: branch de produ\u00e7\u00e3o, onde a documenta\u00e7\u00e3o \u00e9 publicada.  </p> <p>O ideal \u00e9 que cada desenvolvedor crie uma branch local para desenvolver suas documenta\u00e7\u00f5es, e depois fa\u00e7a um pull request para a branch <code>dev</code>. Assim, as documenta\u00e7\u00f5es podem ser revisadas e corrigidas antes de serem publicadas.</p> <p><pre><code>    git branch sua-branch\n    # Depois de fazer as altera\u00e7\u00f5es e commits\n    git switch dev\n    git merge sua-branch\n    git push\n</code></pre> Cuidado para n\u00e3o dar push na sua branch local</p> <p>Caso seu documento seja revisado e aprovado, ele ser\u00e1 movido para a branch <code>main</code> e <code>gh-pages</code> para ser publicado. Caso seu documento seja revisado e aprovado, ele ser\u00e1 movido para a branch <code>main</code> e <code>gh-pages</code> para ser publicado.</p> <p><pre><code>    git switch main\n    git switch main\n    git merge dev\n    git push\n</code></pre> Merge entre dev e main \u00e9 idealmente feita pelo gerente, mas pode ser feita por qualquer membro da equipe mediante aprova\u00e7\u00e3o.</p>"},{"location":"config-projeto/documentacao/#mkdocs","title":"MkDocs","text":"<p>O MkDocs \u00e9 uma ferramenta que permite a cria\u00e7\u00e3o de documenta\u00e7\u00f5es est\u00e1ticas a partir de arquivos Markdown. Ele \u00e9 utilizado para gerar a documenta\u00e7\u00e3o do projeto e public\u00e1-la no GitHub Pages. Como esse projeto \u00e9 baseado em python, \u00e9 necess\u00e1rio criar um ambiente virtual para instalar as depend\u00eancias.</p> <pre><code>    python3 -m venv venv\n    source venv/bin/activate\n    pip install mkdocs mkdocs-material\n</code></pre> <p>Caso o m\u00e9todo anterior n\u00e3o funcione (se o tema n\u00e3o for encontrado ao utilizar <code>mkdocs serve</code>), voc\u00ea pode instalar o MkDocs e o MkDocs Material usando o <code>pip</code> diretamente, mas n\u00e3o \u00e9 recomendado:</p> <p><pre><code>    pip install --break-system-packages mkdocs mkdocs-material\n</code></pre> Com isso voc\u00ea j\u00e1 deve ter tudo necess\u00e1rio para documentar.</p>"},{"location":"config-projeto/documentacao/#workflow","title":"Workflow","text":""},{"location":"config-projeto/documentacao/#desenvolvimento","title":"Desenvolvimento","text":"<p>Para gerar o site de forma concisa e customizada h\u00e1 um arquivo <code>mkdocs.yml</code> que cont\u00e9m as configura\u00e7\u00f5es do site. Nele \u00e9 poss\u00edvel adicionar temas, plugins, e customizar a apar\u00eancia do site. A sintaxe \u00e9 simples e intuitiva, e a documenta\u00e7\u00e3o oficial do MkDocs pode te ajudar muito.</p> <p>Al\u00e9m disso, utilizamos o tema MkDocs Material, que \u00e9 um tema moderno e responsivo, com suporte a dark mode e muitas outras funcionalidades e plugins.</p> <p>Para testar o site localmente, basta rodar o comando:</p> <p><pre><code>    mkdocs serve\n</code></pre> e ele ir\u00e1 gerar um servidor local com o site, que pode ser acessado em <code>http://127.0.0.1:8000/</code>.</p> <p>Erros de sintaxe ou localiza\u00e7\u00e3o de arquivo s\u00e3o mostrados no terminal, e o site \u00e9 atualizado automaticamente a cada altera\u00e7\u00e3o feita nos arquivos Markdown ou estrutura do projeto.</p> <p>\u00c9 comum que ocorram erros em localiza\u00e7\u00e3o de imagens ou outros arquivos de asset, por isso optamos por mante-los no mesmo diret\u00f3rio que o arquivo Markdown que os utiliza.</p> <p>Al\u00e9m disso \u00e9 importante adicionar novos arquivos na se\u00e7\u00e3o <code>nav</code> do arquivo <code>mkdocs.yml</code>, para que eles sejam exibidos no mapa do site.</p>"},{"location":"config-projeto/documentacao/#deploy","title":"Deploy","text":"<p>Para publicar a documenta\u00e7\u00e3o no GitHub Pages, basta rodar o comando:</p> <p><pre><code>    mkdocs gh-deploy\n</code></pre> O comando acima \u00e9 utilizado para publicar a documenta\u00e7\u00e3o no GitHub Pages. Ele gera uma p\u00e1gina est\u00e1tica com a documenta\u00e7\u00e3o e a publica na branch <code>gh-pages</code> automaticamente. A p\u00e1gina pode ser acessada em <code>https://rinobot-team.github.io/SPL-Docs/</code>.</p> <p>\u00c9 de boa pr\u00e1tica que esse deploy seja feito ap\u00f3s a revis\u00e3o e aprova\u00e7\u00e3o da documenta\u00e7\u00e3o e somente na branch <code>main</code>, para evitar erros e problemas de visualiza\u00e7\u00e3o.</p>"},{"location":"config-projeto/imagem-sdk/","title":"Compilando a Imagem pro NAO e adiquirindo a SDK","text":"<p>Essa se\u00e7\u00e3o ainda est\u00e1 incompleta e n\u00e3o est\u00e1 totalmente testada, erros podem ocorrer </p> <p>Atualmente utilizamos o Projeto Yocto para criar uma imagem OPN flash\u00e1vel para o NAO, al\u00e9m de um SDK compat\u00edvel para desenvolvimento direcionado ao rob\u00f4. Esse SDK cont\u00e9m uma toolchain completa para cross-compila\u00e7\u00e3o e pode ser facilmente instalada nos computadores de desenvolvimento.</p> <p>A Rinobot-Jaguar atualmente utiliza o HULKsOS fornecido pela equipe HULKs para os NAOs, no futuro temos inten\u00e7\u00e3o de fazer nossa propria imagem.</p>"},{"location":"config-projeto/imagem-sdk/#tamboerijn-e-yocto-sdk-ja-existentes","title":"Tamboerijn e Yocto SDK j\u00e1 existentes","text":"<p>Se voc\u00ea j\u00e1 possui o SDK do Yocto instalado, e nosso reposi\u00f3rio do Tamboerijn clonado, \u00e9 poss\u00edvel utilizar o <code>pepsi</code> de forma imediata:</p> <p><pre><code>    ./pepsi upload &lt;n\u00famero/IP&gt;\n</code></pre> O <code>pepsi</code> vai automaticamente baixar o SDK do GitHub e perguntar para voc\u00ea para instal\u00e1-lo durante a compila\u00e7\u00e3o.</p>"},{"location":"config-projeto/imagem-sdk/#criacao-da-imagem-e-sdk","title":"Cria\u00e7\u00e3o da Imagem e SDK","text":"<p>O Projeto Yocto utiliza o BitBake como engine de execu\u00e7\u00e3o de tasks e oferece uma camada de abstra\u00e7\u00e3o para a cria\u00e7\u00e3o e modifica\u00e7\u00e3o de imagens j\u00e1 existentes. Combinado com o OpenEmbedded, toda a \u00e1rvore de cria\u00e7\u00e3o \u00e9 estruturada em camadas. Nos baseando no processo utilizado pela HULKs, temos as camadas meta-nao e meta-hulks.</p>"},{"location":"config-projeto/imagem-sdk/#configuracao","title":"Configura\u00e7\u00e3o","text":"<p>Primeiro crie um diret\u00f3rio para trabalhar, tenha pelo menos 100 GB livres de espa\u00e7o interno para evitar erros, esse diret\u00f3rio n\u00e3o pode fazer parte de um reposit\u00f3rio git e de prefer\u00eancia deve ser feito na sua pasta <code>home</code> caso esteja no Linux, por conven\u00e7\u00e3o nomearemos esse diret\u00f3rio de <code>worktree/</code>.</p> <pre><code>    cd ~ # Acessa o diret\u00f3rio home\n    mkdir worktree\n    cd worktree\n</code></pre> <p>Para configura\u00e7\u00e3o do projeto \u00e9 utilizada a framework siemens/kas. Para configurar a estrutura do projeto usaremos a vers\u00e3o em container com o script <code>kas-container</code>, ele pode ser encontrado no reposit\u00f3rio SPL-assets. Para evitar erros recomendamos modificar as permiss\u00f5es do script para que ele possa ser executado:</p> <pre><code>    chmod +x kas-container\n</code></pre> <p>Baixe e instale o Docker. Utilize este comando para testar se o Docker foi instalado corretamente:</p> <pre><code>    docker --version\n</code></pre> <p>Caso ocorra um erro de permiss\u00e3o parecido com este: <code>docker: Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock</code> acesse esta quest\u00e3o do StackOverflow</p> <p>Clone o reposit\u00f3rio <code>meta-nao</code> da HULKs para dentro da pasta <code>worktree/</code>:</p> <pre><code>    git clone git@github.com:hulks/meta-nao\n</code></pre>"},{"location":"config-projeto/imagem-sdk/#criacao-da-imagem","title":"Cria\u00e7\u00e3o da Imagem","text":"<p>O NAOv6 utiliza o LoLA e HAL para comunica\u00e7\u00e3o com a placa do peito. Esses programas s\u00e3o fornecidos pela SoftBank j\u00e1 compilados na imagem OPN de Robocupper. Para consegu\u00ed-los \u00e9 preciso extrair seus bin\u00e1rios da imagem OPN, para isso \u00e9 utilizado o script <code>meta-nao/meta/recipes-support/aldebaran/extract_binaries.sh</code>. Para gerar o arquivo contendo os bin\u00e1rios citados siga esses passos:</p> <pre><code>    cd meta-nao/meta/recipes-support/aldebaran\n    mkdir -p aldebaran-binaries\n    ./extract_binaries.sh -o aldebaran-binaries/aldebaran_binaries.tar.gz &lt;imagem-robocupper.opn&gt;\n</code></pre> <p>Esta imagem pode ser adquirida entrando em contato com a RoboCup SPL TC ou, para membros da Rinobot, baixando-a do Google Drive (Em <code>SPL&gt;Utilit\u00e1rios&gt;Imagens Do Sistema&gt;nao-2.8.5.11_ROBOCUP_ONLY_with_root.opn</code>). TODO: Colocar imagem no reposit\u00f3rio do SPL-assets.</p> <p>Caso ocorra algum erro referente a <code>libguestfs</code> e <code>supermin</code> execute o comando como <code>sudo</code>, em caso de falta do pacote <code>guestmount</code> ou <code>patchelf</code> instale-os com o comando:</p> <pre><code>    sudo apt install guestmount patchelf\n</code></pre> <p>Execute o <code>kas</code> dentro da pasta <code>worktree/</code> referenciando o arquivo e configura\u00e7\u00e3o do projeto <code>kas-project.yml</code>:</p> <pre><code>    ./kas-container -d shell meta-nao/kas-project.yml\n</code></pre> <p>O <code>kas</code> consegue todas as fontes necess\u00e1rias para o build e as configura em seus respectivos diret\u00f3rios dentro do <code>worktree/</code>. O script deve demorar alguns minutos para rodar e ao fim seu diret\u00f3rio de trabalho deve estar parecido com isso:</p> <pre><code>    worktree/\n    \u251c\u2500\u2500 build\n    \u251c\u2500\u2500 meta-clang\n    \u251c\u2500\u2500 meta-congatec-x86\n    \u251c\u2500\u2500 meta-intel\n    \u251c\u2500\u2500 meta-nao\n    \u251c\u2500\u2500 meta-openembedded\n    \u2514\u2500\u2500 poky\n</code></pre> <p>Se o shell do seu container n\u00e3o inicializar voc\u00ea talvez tenha que setar a vari\u00e1vel de ambiente <code>TERM</code> corretamente:</p> <pre><code>    export TERM=xterm\n</code></pre> <p>Para buildar a imagem OPN, execute este comando dentro do terminal do container:</p> <pre><code>    bitbake nao-image\n</code></pre> <p>Isso gera e executa tudo necess\u00e1rio para construir o arquivo <code>.opn</code>. Este processo pode levar algumas horas dependendo da capacidade do seu computador e necessita de conex\u00e3o com a internet. O BitBake possui caching, ent\u00e3o pequenas altera\u00e7\u00f5es n\u00e3o levar\u00e3o tanto tempo, mas na primeira vez prepare uma x\u00edcara de caf\u00e9 e uns p\u00e3es de queijo.</p> <p>Ao final do processo, o arquivo <code>.opn</code> estar\u00e1 dispon\u00edvel em <code>worktree/build/tmp/deploy/images/nao-v6/nao-image-HULKsOS-&lt;vers\u00e3o&gt;.ext3.gz.opn</code>. A partir daqui, o arquivo pode ser gravado em um pendrive e utilizado para flashar o NAO.</p>"},{"location":"config-projeto/imagem-sdk/#migrando-da-hulks-para-rinobot-jaguar","title":"Migrando da HULKs para Rinobot-Jaguar","text":"<p>Esta parte \u00e9 bem imprecisa e ainda n\u00e3o foi testada</p> <p>\u00c9 preciso modificar alguns arquivos com informa\u00e7\u00f5es hardcoded tanto nos arquivos de cria\u00e7\u00e3o de imagem quanto no Tamborijn. Lembrese que o n\u00famero do nosso time na Robocup \u00e9 47. Os IDs de cabe\u00e7a e corpo todos os rob\u00f4s est\u00e3o no Drive da Rino.</p>"},{"location":"config-projeto/imagem-sdk/#modificando-a-imagem-meta-hulks","title":"Modificando a Imagem (meta-hulks)","text":"<p>Em <code>worktree/meta-hulks/recipes-hulks/network-config/configure-network</code> \u00e9 preciso mudar os IPs para o nosso c\u00f3digo, onde tem o 24 da HULKs coloque 47 (Ex: <code>10.1.24.x</code> para <code>10.1.47.x</code>).</p> <p>Em <code>worktree/meta-hulks/recipes-hulks/network-config/network-config/id_map.json</code> \u00e9 preciso colocar os IDs de cabe\u00e7a e corpo de todos os rob\u00f4s. O conte\u00fado do arquivo do drive pode ser s\u00f3 copiado e colado no lugar.</p> <p>As configura\u00e7\u00f5es de conex\u00e3o do wifi podem ser mudadas, o padr\u00e3o j\u00e1 funciona corretamente, mas se for necess\u00e1rio modificar isso basta ir nos arquivos <code>worktree/meta-nao/recipes-conf/nao-wifi-conf/nao-wifi-conf/*.psk</code>.</p> <p>Para mudar o nome da Distro v\u00e1 em <code>worktree/meta-hulks/conf/distro/HULKsOS.conf</code>. \u00c9 necess\u00e1rio mudar a vari\u00e1vel <code>DISTRO</code> e renomear o arquivo com grafia id\u00eantica, al\u00e9m de mudar o nome no <code>meta-hulks/kas-project.yml</code>.</p>"},{"location":"config-projeto/imagem-sdk/#modificando-o-tamboerijn","title":"Modificando o Tamboerijn","text":"<p>Mudar o n\u00famero do time no arquivo <code>crates/spl_network/src/lib.rs</code>.  </p> <p>Em alguns lugares do Pepsi tamb\u00e9m \u00e9 necess\u00e1rio mudar o n\u00famero do time <code>tools/pepsi/src/parsers.rs</code>.  </p> <p>No Twix tamb\u00e9m \u00e9 necess\u00e1rio mudar o n\u00famero do time <code>tools/twix/src/completion_edit.rs</code>.</p> <p>E tamb\u00e9m \u00e9 necess\u00e1rio importar os IDs de cabe\u00e7a e corpo de todos os rob\u00f4s no arquivo <code>etc/configuration/hardware_ids.json</code>.</p>"},{"location":"ferramental/","title":"Ferramental","text":"<p>Al\u00e9m do c\u00f3digo do NAO, nosso repositorio cont\u00e9m um ferramental para facilitar o desenvolvimento, manuten\u00e7\u00e3o e testes do c\u00f3digo. Estas s\u00e3o algumas das ferramentas que utilizamos:   </p> <ul> <li>Pepsi: Multi-ferramenta para automatizar tasks repetitivas, como compila\u00e7\u00e3o e deploy</li> <li>Twix: Ferramenta de Debugging para visualizar dados ao vivo do NAO ou Webots</li> <li>Recording &amp; Replay: Ferramenta para an\u00e1lise de dados de jogo post-mortem</li> <li>Behaviour Simulator: Ferramenta para simular e debugar comportamentos do NAO</li> <li>Aliveness: Ferramenta para status dos NAOs</li> <li>Universal: Conversor dos MotionFiles da Mari para o Tamboerijn.</li> </ul> <p>No futuro planejamos renomear as ferramentas para dar um toque mais latino-brasileiro Pepsi&gt;Caf\u00e9 Twix&gt;Pa\u00e7oca Recording &amp; Replay&gt;VAR Behaviour Simulator&gt;BBB Aliveness&gt;Forr\u00f3</p>"},{"location":"ferramental/aliveness/","title":"Aliveness","text":"<p>\u00c9 um sistema para buscar informa\u00e7\u00f5es de status dos NAOs na rede. Ele consiste de duas partes: O service rodando no NAO e o client rodando no computador.</p>"},{"location":"ferramental/aliveness/#informacoes-disponiveis-via-aliveness","title":"Informa\u00e7\u00f5es Dispon\u00edveis via Aliveness","text":"<p>As seguintes informa\u00e7\u00f5es est\u00e3o dispon\u00edveis via Aliveness:</p> <ul> <li>Hostname</li> <li>Vers\u00e3o atual do HULKs-OS</li> <li>Estados dos servi\u00e7os do sistema: HAL (Hardware Abstraction Layer), HuLA, HULK e LoLA</li> <li>Estado da carga da bateria e corrente</li> <li>ID da cabe\u00e7a</li> <li>ID do corpo</li> <li>Nome na rede Wireless</li> <li>Temperatura de juntas</li> <li>Nome da interface da qual o beacon \u00e9 recebido (atualmente sempre enp4s0)</li> </ul>"},{"location":"ferramental/aliveness/#servico-de-aliveness","title":"Servi\u00e7o de Aliveness","text":"<p>O servi\u00e7o de Aliveness \u00e9 compilado junto com a imagem do HULKs-OS e \u00e9 incluso nele. \u00c9 iniciado com a primeira conex\u00e3o com a rede via Ethernete escuta todas as mensagens enviadas ao endere\u00e7o de multicast <code>224.0.0.42</code> assim como o pr\u00f3prio endere\u00e7o de IP.</p> <p>Quando recebe um pacote UDP com o conte\u00fado <code>BEACON</code>, ele responde com as informa\u00e7\u00f5es a cima. O pacote de resposta \u00e9 um JSON com as informa\u00e7\u00f5es.</p>"},{"location":"ferramental/aliveness/#client-de-aliveness","title":"Client de Aliveness","text":"<p>O Pepsi possui um client de aliveness completo com diferentes n\u00edveis de verbosidade e op\u00e7\u00f5es de exporta\u00e7\u00e3o.</p> <p>Exemplo de uso: <pre><code>    ./pepsi aliveness\n    ./pepsi aliveness 27 32\n    ./pepsi aliveness --json\n    ./pepsi aliveness --timeout 500 -v\n</code></pre></p> <p>Quando executando qualquer um dos subcomandos no pepsi, ele ir\u00e1 mandar a mensagem de beacon citada anteriomente para o endere\u00e7o de multicast ou aos endere\u00e7os de IP dos NAOs. Ent\u00e3o ele coleta todos as respostas dentro do timeout e filtros de acordo com o n\u00edvel de verbosidade escolhido.</p>"},{"location":"ferramental/aliveness/#possiveis-problemas-com-firewall","title":"Poss\u00edveis problemas com Firewall","text":"<p>Quando n\u00e3o h\u00e1 endere\u00e7o do NAO especificado, o beacon \u00e9 mandado via multicast e as respostas s\u00e3o recebidas via unicast. Como as respostas s\u00e3o de diferentes IPs, o firewall pode bloquear as respostas (confunde com um ataque de DDOS).</p> <p>Nesse caso, \u00e9 poss\u00edvel abrir uma permiss\u00e3o no firewall, como exemplo temos o ufw, que \u00e9 o firewall mais comum em sistemas unix: <pre><code>    ufw allow proto udp from 10.1.24.0/24\n</code></pre></p>"},{"location":"ferramental/behaviour-sim/","title":"Behaviour Simulation","text":"<p>TODO</p>"},{"location":"ferramental/pepsi/","title":"Pepsi","text":"<p>Pepsi \u00e9 uma multiferramenta utilizada pra tudo que est\u00e1 no contexto do c\u00f3digo para o NAO. Ela pode ser usada para compilar, modificar par\u00e2metros, fazer deploy no rob\u00f4, abrir um shell remoto com os jogadores, entre outras coisas.</p> <p>Essa p\u00e1gina \u00e9 um resumo das funcionalidades do <code>pepsi</code>. Para instru\u00e7\u00f5es detalhadas utilize o comando <code>pepsi --help</code> ou <code>pepsi &lt;subcomando&gt; --help</code>.</p>"},{"location":"ferramental/pepsi/#webots-workflow","title":"Webots workflow","text":"<p>\u00c9 bem tranquilo. Abra o Webots, carregue o arquivo de mundo <code>webots/worlds/penalized_extern.wbt</code> e execute:</p> <p><pre><code>    ./pepsi run\n</code></pre> Ele ir\u00e1 compilar (se necess\u00e1rio) e repois rodar o bin\u00e1rio do webots. A simula\u00e7\u00e3o \u00e9 pausada automaticamente at\u00e9 que o bin\u00e1rio inicie.</p>"},{"location":"ferramental/pepsi/#nao-workflow","title":"NAO workflow","text":"<p><pre><code>    ./pepsi uplodad &lt;n\u00famero / IP&gt;\n</code></pre> Esse comando faz o seguinte: - Checa se a toolchain est\u00e1 instalado, faz download e instala se for necess\u00e1rio - Compila o c\u00f3digo para o target NAO (<code>pepsi build --target nao</code>) - Faz upload do bin\u00e1rio, par\u00e2metros de configura\u00e7\u00e3o, arquivo de motion, redes neurais, etc. para o rob\u00f4 (deploy) - Reinicia o servi\u00e7o HULKs nos NAOs</p>"},{"location":"ferramental/pepsi/#interacao-com-os-naos","title":"Intera\u00e7\u00e3o com os NAOs","text":"<p>NAOs podem ser identificados tanto por IP quanto por n\u00famero, n\u00fameros s\u00e3o convertidos por IP assim: - <code>{n\u00famero}</code> -&gt; <code>10.1.24.{n\u00famero}</code> - <code>{n\u00famero}w</code> -&gt; <code>10.0.24.{n\u00famero}</code> Muitos subcomandos podem agir em m\u00faltiplos NAOs concorrentemente.</p> <p><code>upload</code> compila o c\u00f3digo e faz o deploy de todos os arquivos bin\u00e1rios e de configura\u00e7\u00e3o para um ou mais rob\u00f4s.</p> <p><code>wireless</code>, <code>reboot</code>, <code>poweroff</code> e <code>hulk</code> interagem diretamente com o rob\u00f4. Enquanto <code>communication</code> e <code>playernumber</code> s\u00f3 alteram par\u00e2metros de configura\u00e7\u00e3o locais.</p> <p><code>pregame</code> combina desativa\u00e7\u00e3o das comunica\u00e7\u00f5es (para evitar a emiss\u00e3o de mensagens ilegais), atribui\u00e7\u00e3o dos n\u00fameros dos jogadores, configura\u00e7\u00e3o das redes de wifi, upload e reinicializa\u00e7\u00e3o do HULK service.</p> <p><code>logs</code> e/ou <code>postgame</code> podem ser usados no p\u00f3s-jogo para coletar logs e reiniciar o servi\u00e7o HULK.</p> <p><code>gammaray</code> \u00e9 utilizado para fazer o flash da imagem do HULKs-OS para um ou mais rob\u00f4s.</p>"},{"location":"ferramental/pepsi/#opcoes-de-build","title":"Op\u00e7\u00f5es de build","text":"<p>Para subcomandos que compilam bin\u00e1rios, \u00e9 poss\u00edvel especificar o alvo e perfil de build. Incluindo <code>build</code>, <code>run</code>, <code>check</code> e <code>clippy</code>.</p>"},{"location":"ferramental/pepsi/#aliveness","title":"Aliveness","text":"<p>Utilizando o subcomando <code>aliveness</code>, a pepsi pode recolher informa\u00e7\u00f5es dos NAOs conectados via ethernet. Por padr\u00e3o, somente informa\u00e7\u00f5es irregulares como sistemas inativos, vers\u00f5es desatualizadas do HULKs-OS e nivel de carga de bateria abaixo de 95% s\u00e3o informados. Usando as flags <code>-v</code> / <code>--verbose</code> ou <code>-j</code> / <code>--json</code> \u00e9 poss\u00edvel obter informa\u00e7\u00f5es mais detalhadas em formato leg\u00edvel para humanos ou computadores.</p> <p>Tamb\u00e9m \u00e9 poss\u00edvel configurar timeouts via <code>t</code> / <code>--timeout</code> (padr\u00e3o de 200ms) e especificar endere\u00e7os (n\u00famero ou IPs) para verificar rob\u00f5s espec\u00edficos.</p> <p>Para mais informa\u00e7\u00f5es, utilize leia esse documento.</p>"},{"location":"ferramental/pepsi/#shell-completion","title":"Shell Completion","text":"<p>Shell completions s\u00e3o configura\u00e7\u00f5es do seu ambiente de shell para que ele complete comandos automaticamente. Para habilitar o shell completion para o <code>pepsi</code>, execute o seguinte comando:</p> <p>Exemplo para zshell <pre><code>    ./pepsi completions zsh &gt; _pepsi \n</code></pre> Consulte a documenta\u00e7\u00e3o do seu ambiente de shell caso use outro (fish, tmux, etc).</p> <p>Para incluir sugest\u00f5es din\u00e2nmicas \u00e9 necess\u00e1rio adicionar ao PATH, para isso utilize este comando:  <pre><code>    cargo install --path tools/pepsi\n</code></pre> e adicionar <code>~/.cargo/bin</code> ao PATH.</p>"},{"location":"ferramental/recording/","title":"Recording and Replay","text":"<p>A framework suporta grava\u00e7\u00e3o de dados e o replay deles depois de uma partida para melhor an\u00e1lise. Para cada inst\u00e2ncia do cycler, somente os inputs e estados dos n\u00f3s no inicio do ciclo s\u00e3o gravados. Durante o replay, esses estados e inputs s\u00e3o usados para recalcular todos os outputs. Um servidor de comunica\u00e7\u00e3o durante o replay pode ser usado para investigar os dados gravados via Twix.</p>"},{"location":"ferramental/recording/#gravacao","title":"Grava\u00e7\u00e3o","text":"<ul> <li>Upload manual para o rob\u00f4<ul> <li>Use <code>./pepsi recording ...</code> para habilitar a grava\u00e7\u00e3o em diferentes taxas<ul> <li>Os par\u00e2metros padr\u00e3o s\u00e3o encontrados em <code>etc/parameters/framework.json</code></li> </ul> </li> <li>Use <code>./pepsi upload ...</code> para fazer o upload normalmente</li> </ul> </li> <li>Pregame<ul> <li>Use <code>./pepsi pregame --recording-intervals ... ...</code> para permitir a grava\u00e7\u00e3o em diferentes taxas em um passo<ul> <li>Isso vai setar os par\u00e2metros de grava\u00e7\u00e3o para os padr\u00f5es do <code>etc/parameters/framework.json</code></li> </ul> </li> </ul> </li> </ul> <p>Seja cauteloso habilitando os cyclers de vis\u00e3o, pois isso resulta em muitos dados sendo gravados. Cyclers de Top e Bottom podem ocupar todo o disco em aproximadamente 10 minutos.</p> <p>Dados s\u00e3o gravados somente durante <code>PrimaryState::Ready</code>, <code>PrimaryState::Set</code> e <code>PrimaryState::Play</code>.</p>"},{"location":"ferramental/recording/#replayer","title":"Replayer","text":"<p>Assumindo que voc\u00ea j\u00e1 gravou alguns dados em um rob\u00f4, \u00e9 possivel utilizar o replayer para revisitar dados gravados.</p> <ul> <li>Fa\u00e7a download dos logs em um diret\u00f3rio <code>logs</code> dentro do reposit\u00f3rio via <code>./pepsi postgame ... meu_replay_gamer ...</code></li> <li>O diret\u00f3rio <code>meu_replay_gamer</code> agora cont\u00e9m diret\u00f3rios com logs de cada rob\u00f4. Cada diret\u00f3rio de rob\u00f4 cont\u00e9m um diret\u00f3rio com dados de replay de uma execu\u00e7\u00e3o do bin\u00e1rio <code>hulk</code>. Todos os arquivos de inst\u00e2ncias de cyclers precisam estar presentes, independente de se est\u00e3o ativos ou n\u00e3o durante a grava\u00e7\u00e3o (neste caso estar\u00e3o vazios)</li> <li>Inicie a ferramenta de replay apontando pro diret\u00f3rio do log que voc\u00ea quer revisitar: <code>./pepsi run --target replayer --meu_replay_gamer/robot1/10.1.24.42/123321</code></li> <li>Conecte seu Twix ao <code>localhost</code> e abra os pain\u00e9is</li> <li>Mova o slider para fazer os dados dispon\u00edveis para o Twix Dica: Clique na caixa de texto e use as setas do teclado para \"animar\"</li> <li>T\u00e1 pronto o sorvetinho</li> </ul>"},{"location":"ferramental/twix/","title":"Twix","text":"<p>TODO</p>"},{"location":"ferramental/universal/","title":"Universal","text":"<p>Universal \u00e9 um c\u00f3digo em python que converte valores que est\u00e3o em graus para radianos.  </p>"},{"location":"ferramental/universal/#uso","title":"Uso","text":"<p>Uma das propostas de melhoria da Rinobot-Jaguar para a Roboup 2024 \u00e9 diminuir o tempo que os rob\u00f4s da HULKS gastam para se levantar ap\u00f3s uma queda. Uma das formas pensadas para essa melhoria, foi utilizar as mesmas sequ\u00eancia de valores usados no projeto Mari de 2018 da Rinobot. </p> <p>Por\u00e9m, um dos problemas encontrados no processo dessa troca, foi o fato dos valores da Mari estarem em graus, e os valores da HULKS estarem em radianos.  </p> <p>Portanto, foi desenvolvido este conversor para facilitar essa tarefa.  </p>"},{"location":"ferramental/universal/#funcionamento","title":"Funcionamento","text":"<p>O c\u00f3digo \u00e9 simples. </p> <ol> <li>Primeiro ele define o caminho para leitura e escrita dos arquivos.  </li> <li>Depois ele  faz a leitura do arquivo linha por linha, selecionando e encontrando os valores em graus e convertendo-os para radianos.  </li> <li>Ao final de cada linha, ele escreve os valores no arquivo de sa\u00edda e ap\u00f3s a leitura de todas as linhas ele finaliza o c\u00f3digo.  </li> </ol>"},{"location":"ferramental/universal/#observacao","title":"Observa\u00e7\u00e3o","text":"<p>O arquivo de coreografia possui algumas linhas de coment\u00e1rios, as quais s\u00e3o come\u00e7adas por \"#\". O c\u00f3digo reconhece essas linhas e apenas as-imprime sem nenhuma altea\u00e7\u00e3o.</p> <p>Este conversor est\u00e1 configurado para funcionar corretamente com os arquivos da Mari ou de arquivos com estrutura igual. N\u00e3o existe nenhuma garantia de que ele funcionar\u00e1 corretamente em quaisquer outro tipo de arquivo.</p>"},{"location":"framework/","title":"Sobre","text":"<p>Esse t\u00f3pico aborda a framework do nosso software para o NAO. Os cap\u00edtulos passam por diversos aspectos numa abordagem \"de cima para baixo\" com uma vis\u00e3o geral, depois detalhando cada parte do sistema. Aqui est\u00e1 uma lista dos cap\u00edtulos:  </p> <ul> <li>Estrutura de diret\u00f3rios: Explica a estutura de pastas do repositorio.   </li> <li>Entry Point: Inicia a abordagem top-down do sistema, explicando o ponto de entrada do programa na fun\u00e7\u00e3o <code>main</code>.   </li> <li>Runtime: Como a runtime faz a conex\u00e3o entre os m\u00f3dulos do sistema?   </li> <li>Cyclers: O que s\u00e3o os cyclers (ciclos de execu\u00e7\u00e3o) e como eles rodam os diferentes n\u00f3s?   </li> <li>N\u00f3s: O que s\u00e3o os n\u00f3s e como eles s\u00e3o implementados?   </li> <li>Bases de dados e Tipos: Como os dados s\u00e3o compartilhados entre cyclers e a framework?   </li> <li>Par\u00e2metros: Como os par\u00e2metros s\u00e3o passados para os n\u00f3s pela framework?   </li> <li>Comunica\u00e7\u00e3o: Do que se trata e como \u00e9 feita a comunica\u00e7\u00e3o entre framework e n\u00f3s? </li> <li>Interface com Hardware: Como o hardware \u00e9 abstra\u00eddo para a framework?   </li> <li>Comunica\u00e7\u00e3o entre threads: Quais conceitos existem para permitir uma comunica\u00e7\u00e3o thread-safe entre os subcomponentes?   </li> <li>Filtragem: Como a filtragem de dados \u00e9 feita na framework e como ela se comporta num software multi-thread?   </li> <li>Macros: Quais macros s\u00e3o usadas para facilitar o desenvolvimento e como eles funcionam?   </li> <li>Tratamento de erros: Como a framework lida com erros e exce\u00e7\u00f5es, e como devo implementar?   </li> </ul> <p>A framework prov\u00ea os principais aspectos necess\u00e1rios para o desenvolvimento de um software para o NAO. Ele tem uma arquitetura modular que permite facil desenvolvimento e substitui\u00e7\u00e3o de n\u00f3s. A framework consiste de quatro componentes fundamentais:   </p> <ul> <li>Runtime: Encapsula todos os subcomponentes, instanciando e inicializando eles.      </li> <li>Interface com Hardware: Abstrai o hardware do NAO, permitindo a comunica\u00e7\u00e3o com os sensores e atuadores.   </li> <li>Cyclers: Cicla entre os n\u00f3s, processa dados do hardware e gera sa\u00eddas.   </li> <li>Comunica\u00e7\u00e3o: Permite a comunica\u00e7\u00e3o entre o framework e outros recursos, como arquivos, n\u00f3s e redes.</li> </ul> <p></p>"},{"location":"framework/SerDe/","title":"Serializa\u00e7\u00e3o e Deserializa\u00e7\u00e3o de Caminhos","text":"<p>A crate <code>path_serde</code> introduz interfaces para serializa\u00e7\u00e3o e deserializa\u00e7\u00e3o de partes espec\u00edficas de tipos atrav\u00e9s de caminhos para seus campos internos. Essa funcionalidade \u00e9 usada principalmente pela Comunica\u00e7\u00e3o para serializar dados e fornec\u00ea-los para nossas ferramentas de debugging.</p>"},{"location":"framework/SerDe/#traits","title":"Traits","text":"<p>A crate fornece 3 traits diferentes: <code>PathSerialize</code>, <code>PathDeserialize</code> e <code>PathIntrospect</code>.</p>"},{"location":"framework/SerDe/#pathserialize","title":"<code>PathSerialize</code>","text":"<p>Esse trait permite a serializa\u00e7\u00e3o de partes de tipos atrav\u00e9s da confirma\u00e7\u00e3o de caminhos para o dado interno desejado. Isso \u00e9 \u00fatil quando somente uma parte do tipo precisa ser serializada.</p> <pre><code>trait PathSerialize {\n    fn serialize_path&lt;S&gt;(&amp;self, path: &amp;str, serializer: S) -&gt; Result&lt;S::Ok, Error&lt;S::Error&gt;&gt;\n    where\n        S: Serializer;\n}\n</code></pre> <p>Por exemplo, um usu\u00e1rio que est\u00e1 interessado somente na posi\u00e7\u00e3o angular da flex\u00e3o de uma junta de tornozelo pode utilizar o  caminho <code>Control.main.sensor_data.positions.ankle_pitch</code> para acessar somente este valor serializado.</p>"},{"location":"framework/SerDe/#pathdeserialize","title":"<code>PathDeserialize</code>","text":"<p>De forma inversa, o trait <code>PathDeserialize</code> facilida a deserializa\u00e7\u00e3o de dados de um caminho definido.</p> <pre><code>trait PathDeserialize {\n    fn deserialize_path&lt;'de, D&gt;(\n        &amp;mut self,\n        path: &amp;str,\n        deserializer: D,\n    ) -&gt; Result&lt;(), Error&lt;D::Error&gt;&gt;\n    where\n        D: Deserializer&lt;'de&gt;;\n}\n</code></pre> <p>Esse funcionalidade \u00e9 utilizada quando mudamos somente partes de um par\u00e2metro.</p>"},{"location":"framework/SerDe/#pathinstrospect","title":"<code>PathInstrospect</code>","text":"<p>Esse trait permite instrospec\u00e7\u00e3o de tipos, ou seja, permite o usu\u00e1rio gerar um conjunto de caminhos poss\u00edveis para os campos de um tipo. Essa funcionalidade \u00e9 importante para explorar dinamicamente a estrutura de tipos de dados. Por exemplo, o ferremental as vezes utiliza para autocompletar caminhos quando se inscrevendo nos dados do rob\u00f4.</p>"},{"location":"framework/SerDe/#macro","title":"Macro","text":"<p>A <code>path_serde</code> tamb\u00e9m prov\u00ea macros de <code>derive</code>, gerando a implementa\u00e7\u00e3o destes traits automaticamente. O c\u00f3digo fonte de um tipo anotado \u00e9 analizado e a implementa\u00e7\u00e3o \u00e9 gerada para cada campo, delegando a chamada para os subtipos.</p>"},{"location":"framework/SerDe/#atributos","title":"Atributos","text":"<p>Tipos e campos podem ser anotados mais a fundo para modificar a gera\u00e7\u00e3o de c\u00f3digo. Cada atributo \u00e9 prefixado com <code>#[path_serde(&lt;...&gt;)]</code> para identific\u00e1-los. S\u00e3o definidos os seguintes atributos:</p>"},{"location":"framework/SerDe/#container-bound","title":"Container: <code>bound</code>","text":"<p>Is atribulo \u00e9 atrelado ao tipo do container e define limites (bounds) gen\u00e9ricos para a implementa\u00e7\u00e3o.</p> <pre><code>#[derive(Serialize, PathSerialize)]\n#[path_serde(bound = T: PathSerialize + Serialize)]\nstruct MyStruct&lt;T&gt; {\n    foo: T,\n}\n</code></pre>"},{"location":"framework/SerDe/#container-add_leaf","title":"Container: <code>add_leaf</code>","text":"<p>Esse atributo adiciona uma folha adicional para os filhos de um tipo especificando o nome e o tipo da folha. Este tipo \u00e9 necess\u00e1rio para implementar o m\u00e9todo <code>TryFrom&lt;Self&gt;</code> que gera dados para o campo quando requisitado.</p> <p>Claramente, <code>container</code> \u00e9 representado como uma \u00e1rvore, por isso a presen\u00e7a de folhas.</p> <pre><code>#[derive(Serialize, PathSerialize)]\n#[path_serde(add_leaf(bar: MyIntoType)]\nstruct MyStruct {\n    foo: i32,\n}\n</code></pre>"},{"location":"framework/SerDe/#campo-leaf","title":"Campo: <code>leaf</code>","text":"<p>Este atributo se trata da folha de uma \u00e1rvore. Isto \u00e9, n\u00e3o se espera que ela tenha filhos, ent\u00e3o a delega\u00e7\u00e3o de um path acaba nele.</p> <pre><code>#[derive(Serialize, PathSerialize)]\npub struct MultivariateNormalDistribution {\n    pub mean: f32,\n    #[path_serde(leaf)]\n    pub covariance: FancyType,\n}\n</code></pre>"},{"location":"framework/SerDe/#campo-skip","title":"Campo: <code>skip</code>","text":"<p>Este atributo especifica que o campo marcado deve ser pulado na implementa\u00e7\u00e3o. Ele n\u00e3o sera incluido na (de)serializa\u00e7\u00e3o ou na instrospec\u00e7\u00e3o.</p> <pre><code>#[derive(Serialize, PathSerialize)]\npub struct MultivariateNormalDistribution {\n    pub mean: f32,\n    #[path_serde(skip)]\n    pub covariance: FancyType,\n}\n</code></pre>"},{"location":"framework/SerDe/#exemplo-de-uso","title":"Exemplo de Uso","text":"<pre><code>#[derive(PathSerialize, PathDeserialize, PathIntrospect)]\nstruct ExampleStruct {\n    foo: u32,\n    bar: String,\n}\n\nfn main() {\n    let example = ExampleStruct {\n        foo: 42,\n        bar: String::from(\"example\"),\n    };\n\n    let serialized_data = example.serialize_path(\"foo\", /* serializer */); // (1)\n\n    let deserialized_data = example.deserialize_path(\"bar\", /* deserializer */); // (2)\n\n    let available_paths = ExampleStruct::get_fields(); // (3)\n}\n</code></pre> <ol> <li>Serializa os dados usando path.</li> <li>Deserializar os dados a partir de um path especifico.</li> <li>Gera um conjunto com todos os paths disponiveis dentro de <code>ExampleStruct</code>.</li> </ol>"},{"location":"framework/communication/","title":"Comunica\u00e7\u00e3o","text":"<p>A Comunica\u00e7\u00e3o \u00e9 o subcomponente da framework que faz os cyclers audit\u00e1veis para o mundo externo. Ao passo que os cyclers necessitam rodar em tempo real, a comunica\u00e7\u00e3o n\u00e3o tem esse requerimento. J\u00e1 que ela lida com I/O externo e aplica\u00e7\u00f5es conectadas atrav\u00e9s da rede, que podem influenciar na performance e responsividade, a comunica\u00e7\u00e3o apresenta toda suas funcionalidades em um m\u00e9todo de melhor esfor\u00e7o (best-effort), e, dessa forma, retira essa responsabilidade dos cyclers.</p> <p>Em um alto n\u00edvel, a comunica\u00e7\u00e3o permite aplica\u00e7\u00f5es externas \u00e0:   </p> <ul> <li>Inscrever-se em databases de cyclers e receber campos selecionados delas (<code>database_subscription_manager</code>)  </li> <li>Inscrever-se em par\u00e2metros de configura\u00e7\u00e3o, receber modificados e atualiz\u00e1-los (<code>parameter_modification</code>)  </li> </ul>"},{"location":"framework/communication/#canais-assincronos-e-tasks","title":"Canais Ass\u00edncronos e Tasks","text":"<p>J\u00e1 que a comunica\u00e7\u00e3o lida com I/O (entrada e sa\u00edda de dados) e est\u00e1 inativo a maior parte do tempo esperando por esse I/O, ela \u00e9 implementada como um subcomponente ass\u00edncrono (usando a crate Tokio do Rust) utilizando o paradigma de message passing. As partes da comunica\u00e7\u00e3o s\u00e3o executadas como tasks (tarefas) ass\u00edncronas que s\u00e3o conectadas via canais de passagem de mensagem. O seguinte diagrama mostra todas as tasks de comunica\u00e7\u00e3o como caixas retangulares (exceto as threads dos cyclers, que podem ou n\u00e3o ser vistas como tasks):</p> <p></p> <p>Conex\u00f5es s\u00f3lidas representam fluxos de dados implementados com canais. Conex\u00f5es tracejadas representam o comportamento de inicializa\u00e7\u00e3o de tasks.</p>"},{"location":"framework/communication/#criacao-de-tasks-e-gerenciamento-de-conexoes","title":"Cria\u00e7\u00e3o de Tasks e Gerenciamento de Conex\u00f5es","text":"<p>O ponto de entrada \u00e9 o Runtime de Comunica\u00e7\u00e3o, que se trata de uma thread rodando o Runtime Ass\u00edncrono do Tokio. Essa thread \u00e9 iniciada a partir do Runtime da framework, similarmente ao runtime dos cyclers. O runtime de comunica\u00e7\u00e3o da origem \u00e0 novas tasks e conecta ela por canais:  </p> <ul> <li><code>accepter</code> task: Escuta por novas conex\u00f5es no socket e instancia uma nova <code>connection</code> task para cada conex\u00e3o aceita  </li> <li><code>connection</code> task: \u00c9 uma task de curta vida que divide a conex\u00e3o com o socket entre uma metade receptora e uma emissora e cria duas novas tasks de vida longa, uma <code>sender</code> e uma <code>receiver</code>. Essa cis\u00e3o permite que estas tasks de longa vida se comportem como tasks de multiplexing e desmultiplexing.  <ul> <li><code>sender</code> task: Reune todas as mensagens das tasks conectadas e as envia para o socket.  </li> <li><code>receiver</code> task: Interpreta mensagens vindas do socket e as encaminha para a task de processamento adequada (<code>database_subscription_manager</code> ou <code>parameter_modification</code>).  </li> </ul> </li> </ul>"},{"location":"framework/communication/#inscricoes-de-database","title":"Inscri\u00e7\u00f5es de Database","text":"<p>A comunica\u00e7\u00e3o permite que os clientes conectados se inscrevam nos cyclers e recebam campos selecionados de suas databases. Inscri\u00e7\u00f5es s\u00e3o gerenciadas na task <code>database_subscription_manager</code>. A task <code>receiver</code> \u00e9 respons\u00e1vel por encaminhar requisi\u00e7\u00f5es de (des)incri\u00e7\u00e3o do client \u00e0  <code>database_subscription_manager</code>. Se a conex\u00e3o for fechada, o <code>receiver</code> manda uma requisi\u00e7\u00e3o de <code>UnsubscribeEverything</code> ao gerente da task. J\u00e1 que toda intera\u00e7\u00e3o entre tasks ocorre via canais, em algumas requisi\u00e7\u00f5es \u00e9 necess\u00e1rio incluir os endpoints de outros canais (como o retorno de resultados por exemplo). Inscri\u00e7\u00f5es sempre cont\u00e9m um cycler, tipo de sa\u00edda e caminho dos dados. Se os cyclers completarem sua execu\u00e7\u00e3o de todos os m\u00f3dulos internos a database \u00e9 completada e liberada. Depois, o cycler notifica com uma requisi\u00e7\u00e3o de <code>Notify</code> que \u00e9 compartilhada entre cycler e o <code>database_subscription_manager</code> na comunica\u00e7\u00e3o. Isso permite que o gerenciador espere por novas databases dispon\u00edveis de qualquer cycler. Quando uma nova database \u00e9 disponibilizada, a task gerente itera sobre todas as incri\u00e7\u00f5es relevantes e extrai tipos e imagens inscritas para construir mensagens para os clients inscritos. Sa\u00eddas adicionais que podem estar inscritas s\u00e3o direcionadas ao cycler para que ele instrua os m\u00f3dulos a gerarem as sa\u00eddas adicionais.</p>"},{"location":"framework/communication/#inscricao-de-parametros-e-atualizacoes","title":"Inscri\u00e7\u00e3o de Par\u00e2metros e Atualiza\u00e7\u00f5es","text":"<p>A Comunica\u00e7\u00e3o permite que os clientes conectados se inscrevam em par\u00e2metros de configura\u00e7\u00e3o, receba modificados e os atualize. De forma an\u00e1loga \u00e0s inscri\u00e7\u00f5es de database, inscri\u00e7\u00f5es de par\u00e2metros s\u00e3o processadas pela task <code>receiver</code>.</p> <p>TODO: - WebSocket e Protocolos / JSON (De)Serializa\u00e7\u00e3o     - Acceptor     - Inicializa\u00e7\u00e3o do socket (handshake)     - Sender / Receiver     - Formato das mensagens</p>"},{"location":"framework/cyclers/","title":"Cyclers","text":"<p>Um cycler no sistema de controle rob\u00f3tico Tamboerijn \u00e9 um sobcomponente que cicla os n\u00f3s. O nome \"cycler\" vem da sua caracter\u00edstica principal, ele cont\u00e9m um loop que itera sobre os dados que est\u00e3o entrando e produz algum dado de sa\u00edda em cada itera\u00e7\u00e3o. Os cyclers chamam seu m\u00e9todo interno <code>cycle()</code> em cada itera\u00e7\u00e3o, esse m\u00e9todo consiste de tr\u1ebds etapas:   </p> <ol> <li>Setup: Espera por dados novos e prepara o ciclo.   </li> <li>Processamento: Roda os n\u00f3s necess\u00e1rios nos dados recebidos.   </li> <li>T\u00e9rmino: Manda comando para os atuadores e guarda os dados anteriores antes de chamar o pr\u00f3ximo ciclo.</li> </ol> <p>Existem m\u00faltiplos cyclers em todo o software, e uma das principais tarefas da framework \u00e9 permitir que eles comuniquem entre si. Por exemplo, na etapa de setup, dados de outros cyclers e da comunica\u00e7\u00e3o s\u00e3o coletado. Ou, na etapa de t\u00e9rmino, os dados produzidos durante o processamento s\u00e3o enviados para outros cyclers, caso necess\u00e1rio.</p> <p>Cyclers s\u00e3o separados em duas categorias:  </p> <ol> <li>Cyclers de tempo real: Usados para controle do rob\u00f4, como em atuadores.  </li> <li>Cyclers de percep\u00e7\u00e3o: Usados para processar dados de sensores, como o de vis\u00e3o por exemplo.  </li> </ol>"},{"location":"framework/cyclers/#cycler-de-tempo-real","title":"Cycler de tempo real","text":"<p>Um cycler de tempo real existe externamente ao ambiente, integra dados ori\u00fandos dos cyclers de perce\u00e7\u00e3o, e produz alguma sa\u00edda no fim do ciclo. Um exemplo \u00e9 o cycler que roda em tempo real sincronizado com o intervalo do LoLA (83 hz), ele recebe dados de sensores do HULA/LoLA atrav\u00e9s da interface de hardware e cria uma sa\u00edda para os atuadores que \u00e9 mandada de volta para o HULA/LoLA. O cycler de controle integra dados de todos os outros cyclers de percep\u00e3o (\u00e1udio, SPL network e vis\u00e3o) em sua pipeline de filtragem. Mais informa\u00e7\u00f5es sobre essa pipeline podem ser encontradas em Filtragem. O cycler de controle comt\u00e9m todo c\u00f3digo de rob\u00f3tica que precisa ser avaliado em cada ciclo de tempo real. Em outras palavras, ele possui todos os n\u00f3s necess\u00e1rios para gerar novos outputs. Qualquer n\u00f3 que seja muito custoso computacionalmente, como a vis\u00e3o, \u00e9 executada em seu pr\u00f3prio cycler de percep\u00e7\u00e3o.</p>"},{"location":"framework/cyclers/#cycler-de-percepcao","title":"Cycler de percep\u00e7\u00e3o","text":"<p>Al\u00e9m dos cyclers de tempo real centrais, existem m\u00faltiplos cyclers de percep\u00e7\u00e3o que percebem dados do mundo exterior e pr\u00e9-processam eles. A sa\u00edda de cada cycler de percep\u00e7\u00e3o \u00e9 integrada aos cyclers de tempo real para respeitar suas sa\u00eddas de tempo real. J\u00e1 que cyclers de percep\u00e7\u00e3o rodam em paralelo aos de tempo real - e s\u00e3o capazes de reter dados hist\u00f3ricos - eles podem rodar em intervalos de ciclo distintos. Esses cyclers normalmente esperam por um evente engatilhado externamente, como nova imagem da camera ou mensagem da rede por exemplo. Com isso, o in\u00edcio do processamento \u00e9 anunciado aos cyclers de tempo real na etapa de setup, al\u00e9m de adiquirir dados requisitados dos cyclers de tempo real. A sa\u00edda de dado dos cyclers de percep\u00e7\u00e3o \u00e9 ent\u00e3o enviada para os cyclers de tempo real na etapa de t\u00e9rmino. Mais informa\u00e7\u00f5es sobre os dados que transitam entre cyclers pode ser encontrada em Filtragem. Os cyclers de percep\u00e7\u00e3o existentes s\u00e3o:   </p> <ol> <li>audio: Recebe dados de \u00e1udio da Interface de Hardware, basicamente dados dos microfones do NAO, principalemente para reconhecimento de apito.   </li> <li>spl_network: Espera por mensagens vindas da rede ou requests de envio de mensagem vindo de outros cycler. Cada ciclo ele, ou pr\u00e9-processa mensagens recebidas via parsing (an\u00e1lise sint\u00e1tica), ou envia mensagens para o exterior, a rede.   </li> <li>vision_top: Recebe dados da camera superioro do NAO via Interface de Hardware, e processa a imagem para retirar e identificar diferentes features.   </li> <li>vision_bottom: Similar ao <code>vision_top</code>, mas para a camera inferior do NAO.</li> </ol>"},{"location":"framework/databases-types/","title":"Databases e Tipos","text":"<p>Os m\u00f3dulos podem produzir tipos n\u00e3o padr\u00f5es. Esses tipos especificos s\u00e3o definidos no diret\u00f3rio <code>crates/types</code>.</p> <p>Uma database cont\u00e9m todas as sa\u00eddas dos n\u00f3s dentro de um ciclo. Para cara cycler existe uma database onde ele armazena suas sa\u00eddas. Elas s\u00e3o representadas por uma struct de Rust. Se um n\u00f3 precisa de uma entrada, a refer\u00eancia para o campo que esse dado ocupar\u00e1 na database \u00e9 passada para o n\u00f3.   </p> <p>Esses campos podem conter o tipo <code>Option</code> do Rust, regularmente \u00e9 utilizado <code>Option::Some</code> para representar que o campo foi gerado e pode ser usado. Tamb\u00e9m h\u00e1 o <code>Option::None</code> que pode ser interpretado como um erro leve em que o n\u00f3 de origem n\u00e3o conseguiu gerar o output neste ciclo. Isso pode acontercer por exemplo quando a proje\u00e7\u00e3o da c\u00e2mera n\u00e3o \u00e9 valida neste ciclo. Por\u00e9m, databases tamb\u00e9m podem conter tipos padr\u00f5es de Rust, por exemplo, se o n\u00f3 produz um <code>f32</code> como sa\u00edda. Mais informa\u00e7\u00f5es sobre os tipos codificados em Option podem ser encontrados em Tratamento de Erros e Macros.</p> <p>TODO: Elaborar mais sobre. TODO: Explicar serializa\u00e7\u00e3o e deserializa\u00e7\u00e3o dos tipos.</p>"},{"location":"framework/directory-struct/","title":"Estrutura de diret\u00f3rios","text":"<p>Importante: diret\u00f3rio = pasta</p> <p>O repostit\u00f3rio do programa \u00e9 classificado como monorepo, ou seja, todos os c\u00f3digos fontes est\u00e3o em um \u00fanico reposit\u00f3rio. A estrutura de diret\u00f3rios \u00e9 organizada de forma a facilitar a navega\u00e7\u00e3o e a compreens\u00e3o do c\u00f3digo. Aqui est\u00e1 uma vis\u00e3o geral da estrutura de diret\u00f3rios:  </p> <ul> <li><code>crates/</code>: Cont\u00e9m diverentes crates (m\u00f3dulos) que comp\u00f5em o programa, al\u00e9m de outras crates para rob\u00f3tica e ferramental.  <ul> <li><code>code_generation/</code>: Assim que o c\u00f3digo fonte \u00e9 analizado, essa crate vai gerar o c\u00f3digo necess\u00e1rio para a execu\u00e7\u00e3o dos cyclers e n\u00f3s.  </li> <li><code>communication/</code>: O servidor de comunica\u00e7\u00e3o (para a framework) e client (para o ferramental de debug).   </li> <li><code>context_attribute/</code>: Cont\u00e9m o proc-macro <code>#[context]</code> usado nos n\u00f3s para prepar\u00e1-los para a execu\u00e7\u00e3o.  </li> <li><code>framework/</code>: Blocos de constru\u00e7\u00e3o para a framework de execu\u00e7\u00e3o e alguns tipos necess\u00e1rios para o programa.  </li> <li><code>parameters/</code>: Funcionalidades para os par\u00e2metros do programa (serializa\u00e7\u00e3o e deserializa\u00e7\u00e3o).  </li> <li><code>serialize_hierarchy/</code>: Traits necess\u00e1rios para todos os tipos da Comunica\u00e7\u00e3o.  </li> <li><code>serialize_hierarchy_derive/</code>: Macro de deriva\u00e7\u00e3o para o trait <code>SerializeHierarchy</code>.  </li> </ul> </li> <li><code>etc/</code>: Todos os arquivos adicionais para o deploy do programa para o NAO.  <ul> <li><code>parameters/</code>: Arquivos de par\u00e2metros enviados para o NAO e lidos durante a execu\u00e7\u00e3o.  </li> </ul> </li> <li><code>tools/</code>: Ferramentas para auxiliar no desenvolvimento e debug do programa.  <ul> <li><code>pepsi/</code>: Ferramenta para compilar e comunicar com o NAO.  </li> <li><code>twix/</code>: Ferramenta para debugar o programa.  </li> </ul> </li> </ul>"},{"location":"framework/entry-point/","title":"Entry Point dos Processos","text":"<p>O software de controle rob\u00f3tico Tamboerijn pode ser compilado para diferentes plataformas, NAO e Webots. Para cada plataforma h\u00e1 um bin\u00e1rio compilado diferente, e um ponto de entrada do programa diferente. Neste documento, vamos explicar o ponto de entrada para cada plataforma. Todos os execut\u00e1veis definem uma fun\u00e7\u00e3o <code>main()</code> que \u00e9 o ponto de entrada do programa, veja <code>crates/hulks_nao</code> ou <code>crates/hulks_webots</code> para mais detalhes. Os pr\u00f3ximos par\u00e1grafos explicam os primeiros passos do programa em ambas as plataformas.</p>"},{"location":"framework/entry-point/#parametros-de-hardware","title":"Par\u00e2metros de hardware","text":"<p>No final da fun\u00e7\u00e3o <code>main()</code>, as interfaces de hardware s\u00e3o criadas. Al\u00e9m do dom\u00ednio da rob\u00f3tica, a interface de hardware tamb\u00e9m necessita de alguns par\u00e2metros para inicializar o hardware. Esses par\u00e2metros s\u00e3o lidos de um arquivo JSON que pode ser passado como primeiro argumento na linha de comando do execut\u00e1vel. Se omitido, o arquvio padr\u00e3o <code>etc/parameters/hardware.json</code> \u00e9 carregado.</p>"},{"location":"framework/entry-point/#desligamento-e-cancellationtoken","title":"Desligamento e CancellationToken","text":"<p>As fun\u00e7\u00f5es <code>main()</code> para ambas as plataformas registram o desligamento por meio da biblioteca ctrlc. Os handlers desse desligamento reagem com os sinais padr\u00e3o do Linux <code>SIGINT</code> e <code>SIGTERM</code>, chamando o <code>CancellationToken::cancelled()</code> que cancela o token assim que receber o sinal de desligamento. O <code>CancellationToken</code> \u00e9 um primitivo de sincroniza\u00e7\u00e3o que \u00e9 compartilhado em toda a framework permitindo desligar todos os componentes de qualquer local do c\u00f3digo. Diversos lugares escutam pelo evento de <code>cancelled()</code> e terminam assim que ouver cancelamento. Al\u00e9m de cancelar com a o token <code>CancellationToken</code> sob sinal do Linux, condi\u00e7\u00f5es de erro dentro do sistema de controle dos rob\u00f4s tamb\u00e9m podem engatilhar o cancelamento. Esses conceitos permitem que o programa seja desligado de forma segura e r\u00e1pida em caso de erro ou requisi\u00e7\u00e3o de t\u00e9rmino.</p>"},{"location":"framework/entry-point/#interface-de-hardware-e-runtime","title":"Interface de hardware e Runtime","text":"<p>Tanto no NAO quanto no Webots, o software de controle dos rob\u00f4s precisa de acesso ao hardware ou interface simulada. A interface de hardware prov\u00ea uma maneira abstrata de interagir com o backend \"abaixo\". A fun\u00e7\u00e3o <code>main()</code> primeiro inicia a interface de hardware, e depois inicia o runtime (<code>run()</code>) com ela. Veja Interface de Hardware para mais informa\u00e7\u00f5es sobre o que a interface inicializa.</p>"},{"location":"framework/error-handling/","title":"Tratamento de Erros","text":"<p>Documenta\u00e7\u00e3o detalhada ainda n\u00e3o fornecida pela HULKs</p>"},{"location":"framework/error-handling/#todo-elaborar","title":"TODO: Elaborar","text":"<ul> <li>Tratamento de Erros<ul> <li>3 maneirs de tratar erros<ul> <li>Configurar uma sa\u00edda principal para <code>none</code>: Acontece quando o n\u00f3 n\u00e3o consegue gerar essa sa\u00edda (por exemplo, quando as entradas n\u00e3o est\u00e3o dispon\u00edveis ou houve um erro tempor\u00e1rio dentro do n\u00f3)<ul> <li>Recuper\u00e1vel, esperado que seja resolvido no pr\u00f3ximo ciclo</li> </ul> </li> <li>Retorno <code>Err(...)</code> de <code>cycle()</code><ul> <li>Inrecuper\u00e1vel, mas a framework pode desligar graciosamente, esperado que n\u00e3o melhore nos pr\u00f3ximos ciclos/no futuro</li> </ul> </li> <li>Panic no <code>panic!()</code> ou durante <code>unwrap()</code><ul> <li>Inrecuper\u00e1vel, desligamento imediato, o kernel derrubar\u00e1 todo o processo, n\u00e3o h\u00e1 maneira de desligar graciosamente</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"framework/filtering/","title":"Filtragem","text":"<p>Documenta\u00e7\u00e3o detalhada ainda n\u00e3o fornecida pela HULKs</p>"},{"location":"framework/filtering/#todo-elaborar","title":"TODO: Elaborar","text":"<ul> <li>FutureQueue/Filtragem<ul> <li>Resumo: Diagrama de tempo</li> <li>Motiva\u00e7\u00e3o: Filtros precisam de atualiza\u00e7\u00f5es mon\u00f3tonas<ul> <li>O que o n\u00f3 de filtragem tem de fazer em cada ciclo?<ul> <li>Reverter medi\u00e7\u00f5es tempor\u00e1rias do \u00faltimo ciclo</li> <li>Aplicar medi\u00e7\u00f5es persistentes</li> <li>Aplicar medi\u00e7\u00f5es tempor\u00e1rias</li> </ul> </li> </ul> </li> <li>FutureQueue (cada Cycler de Percep\u00e7\u00e3o tem um para comunicar com Controle)<ul> <li>Produtor<ul> <li>anunciar</li> <li>finalizar</li> </ul> </li> <li>Consumidor<ul> <li>consumir</li> </ul> </li> </ul> </li> <li>PersistentDatabases consomem de m\u00faltiplas FutureQueues e reorganizam dados<ul> <li>persistente vs. tempor\u00e1rio</li> </ul> </li> <li>PersistentInputs (Interface para os n\u00f3s de filtro)<ul> <li>persistente vs. tempor\u00e1rio</li> </ul> </li> </ul> </li> </ul>"},{"location":"framework/hardware-interface/","title":"Interface com Hardware","text":"<p>Documenta\u00e7\u00e3o detalhada ainda n\u00e3o fornecida pela HULKs</p>"},{"location":"framework/hardware-interface/#todo-elaborar","title":"TODO: Elaborar","text":"<ul> <li>Interface de Hardware<ul> <li><code>trait</code><ul> <li><code>produce_sensor_data()</code></li> </ul> </li> <li>NAO<ul> <li>Aquisi\u00e7\u00e3o de HardwareId (do HULA)</li> <li>LoLA/HAL/HULA<ul> <li>Explicar siglas</li> <li>Resumo: Estado/Conex\u00e3o/Rede/Diagrama de Componentes, Modelo de DataFlow</li> <li>Localiza\u00e7\u00e3o do socket e explica\u00e7\u00e3o do UnixSocket</li> <li>Proxy<ul> <li>Extra\u00e7\u00e3o e injetor de mensagens</li> <li>Formata\u00e7\u00e3o de mensagens</li> <li>Anima\u00e7\u00f5es dos LEDs</li> </ul> </li> <li>Aliveness<ul> <li>Rede: Formato de mensagem, UDP, multicast, JSON</li> <li>Estados de servi\u00e7o</li> </ul> </li> <li><code>produce_sensor_data()</code></li> </ul> </li> <li>Cameras<ul> <li>Video4Linux</li> <li>Buffering, Zero-copy (-&gt; Cycler)</li> <li>Configura\u00e7\u00e3o de c\u00e2meras (registers)</li> </ul> </li> <li>Audio<ul> <li>ALSA</li> <li>Configura\u00e7\u00e3o do ALSA</li> <li>Depois: Audio playback, Text-to-speech</li> </ul> </li> </ul> </li> <li>Webots<ul> <li>Aquisi\u00e7\u00e3o de HardwareId (robot name)</li> <li>Webots bindings</li> <li><code>produce_sensor_data()</code></li> <li>Transfer\u00eancia de \u00e1udio e imagem para diferentes threads</li> <li>Simulation World</li> <li>Estrutura de diret\u00f3rios e symlink</li> </ul> </li> </ul> </li> </ul>"},{"location":"framework/macros/","title":"Macros","text":"<p>Documenta\u00e7\u00e3o detalhada ainda n\u00e3o fornecida pela HULKs</p>"},{"location":"framework/macros/#todo-elaborar","title":"TODO: Elaborar","text":"<ul> <li>Macros<ul> <li>O que \u00e9 um Macro em Rust? Recebe um TokenStream como input e consegue transformar ele e sair como um novo TokenStream</li> <li>Objetivo: reduzir duplica\u00e7\u00e3o de c\u00f3digo, reduzir c\u00f3digo escrito manualmente</li> <li>N\u00f3s<ul> <li>Declara\u00e7\u00e3o de n\u00f3 <code>#[node(...)]</code><ul> <li>Ligar ao <code>impl Node {}</code></li> <li>Adicionar <code>struct CycleContext</code><ul> <li>Cont\u00e9m inputs, outputs adicionais, etc.</li> </ul> </li> <li>Adicionar <code>impl CycleContext { fn new(...) -&gt; CycleContext {} }</code></li> <li>Adicionar <code>struct MainOutputs</code><ul> <li>Cont\u00e9m outputs principais</li> </ul> </li> <li>Adicionar <code>impl MainOutputs { fn update(...) {} fn none() {} }</code></li> <li>Modificar <code>impl Node {}</code>: Adicionar <code>fn run_cycle() {}</code><ul> <li>Criar <code>CycleContext</code> e <code>MainOutputs</code></li> <li>Chamar o m\u00e9todo <code>cycle()</code> de um n\u00f3</li> </ul> </li> </ul> </li> <li>Inputs<ul> <li>Input <code>#[input(path, data_type, cycler, name)]</code> recebe dados do ciclo atual dentro do cycler atual</li> <li>Dentro do cycler de controle:<ul> <li>Historic Input <code>#[historic_input(path, data_type, name)]</code> Recebe dados hist\u00f3ricos do cycler de controle</li> <li>Perception Input <code>#[perception_input(path, data_type, cycler, name)]</code> Recebe dados de percep\u00e7\u00e3o de um cycler de percep\u00e7\u00e3o</li> <li>Persistent State <code>#[persistent_state(path, data_type, name)]</code> Estado compartilhado entre n\u00f3s sobre m\u00faltiplos ciclos</li> </ul> </li> <li>Parameter <code>#[parameter(data_type, name, path, on_changed)]</code> Recebe par\u00e2metros de configura\u00e7\u00e3o do arquivo de configura\u00e7\u00e3o/via Communication</li> </ul> </li> <li>Outputs<ul> <li>Main Output <code>#[main_output(data_type, name)]</code> Sa\u00edda para n\u00f3s dependentes, gerado a cada ciclo</li> <li>Additional Output <code>#[additional_output(path, data_type, name)]</code> Sa\u00edda opcional que pode ser habilitada / requisitada pela Comunica\u00e7\u00e3o</li> </ul> </li> </ul> </li> <li><code>require_some!</code> TODO: <code>required</code> flag?    <ul> <li>Extrai dados do contexto do ciclo e retorna <code>none</code> para todas as sa\u00eddas principais se a entrada for nenhuma</li> <li><code>require_some!(...) =&gt; match ... { Some(...) =&gt; ..., None =&gt; return MainOutputs::none() }</code></li> </ul> </li> <li>SerializeHierarchy<ul> <li>Trait<ul> <li>Principalemnte usado pela Comunica\u00e7\u00e3o para (de-)serializa\u00e7\u00e3o</li> <li>Adiciona suporte para caminhos de campos</li> <li>Permite (de-)serializa\u00e7\u00e3o para / de caminhos de campos <code>fn serialize_hierarchy(field_path)</code>, <code>fn deserialize_hierarchy(field_path, data)</code></li> <li>Permite verificar se um caminho de campo existe</li> <li>Permite gerar um objeto de hierarquia</li> <li>Implementado para todas as databases e configura\u00e7\u00f5es</li> </ul> </li> <li>Macro <code>#[derive(SerializeHierarchy)]</code><ul> <li>Ligado a structs</li> <li>Gera<code>impl SerializeHierarchy for ... { ... }</code><ul> <li>Itera sobre todos os campos e delega chamadas de fun\u00e7\u00e3o para os campos</li> </ul> </li> </ul> </li> </ul> </li> <li>3rd-party macros: <code>nalgebra::point</code> ou <code>nalgebra::matrix</code><ul> <li>Link para macros de terceiros</li> </ul> </li> </ul> </li> </ul>"},{"location":"framework/nodes/","title":"Nodes (N\u00f3s)","text":"<p>Os N\u00f3s normalmente cont\u00e9m c\u00f3digo de rob\u00f3tica propriamente dito e s\u00e3o intercambi\u00e1veis entre cyclers. Cada n\u00f3 \u00e9 caracterizado po uma fun\u00e7\u00e3o <code>cycle()</code> que \u00e9 chamada em cada ciclo. Essa fun\u00e7\u00e3o pega os inputs do n\u00f3 como par\u00e2metros e retorna os outputs deste node. Al\u00e9m disso, n\u00f3s possuem um estado que \u00e9 preservado entre ciclos.</p> <p></p> <p>N\u00f3s s\u00e3o structs normais do Rust em que os campos da struct representam o estado, e um m\u00e9todo chamado <code>cycle()</code> no <code>impl</code> do n\u00f3 que representa a fun\u00e7\u00e3o de ciclo. Esse conceito permite escrever os n\u00f3s na forma mais otimizada para a linguagem Rust. Um n\u00f3 pode ter multiplos inputs de diferentes tipos que podem ser adicionados ao struct. Aqui est\u00e1 um exemplo de n\u00f3, mais informa\u00e7\u00e3o pode ser encontrada em Macros:  </p> <pre><code>use std::{collections::VecDeque, time::SystemTime};\n\nuse color_eyre::Result;\nuse context_attribute::context;\nuse framework::{MainOutput, PerceptionInput};\nuse serde::{Deserialize, Serialize};\nuse types::{cycle_time::CycleTime, filtered_whistle::FilteredWhistle, whistle::Whistle};\n\n#[derive(Deserialize, Serialize)]\npub struct WhistleFilter { // (1)\n    detection_buffer: VecDeque&lt;bool&gt;,\n    was_detected_last_cycle: bool,\n    last_detection: Option&lt;SystemTime&gt;,\n}\n\n#[context]\npub struct CreationContext {} // (2)\n\n#[context]\npub struct CycleContext { // (3)\n    buffer_length: Parameter&lt;usize, \"whistle_filter.buffer_length\"&gt;, // (4)\n    minimum_detections: Parameter&lt;usize, \"whistle_filter.minimum_detections\"&gt;,\n    cycle_time: Input&lt;CycleTime, \"cycle_time\"&gt;, // (5)\n    detected_whistle: PerceptionInput&lt;Whistle, \"Audio\", \"detected_whistle\"&gt;, // (6)\n}\n\n#[context]\n#[derive(Default)]\npub struct MainOutputs {\n    pub filtered_whistle: MainOutput&lt;FilteredWhistle&gt;,\n}\n\nimpl WhistleFilter {\n    pub fn new(_context: CreationContext) -&gt; Result&lt;Self&gt; { // (7)\n        Ok(Self {\n            detection_buffer: Default::default(),\n            was_detected_last_cycle: false,\n            last_detection: None,\n        })\n    }\n\n    pub fn cycle(&amp;mut self, context: CycleContext) -&gt; Result&lt;MainOutputs&gt; { // (8)\n        let cycle_start_time = context.cycle_time.start_time;\n\n        for &amp;is_detected in context\n            .detected_whistle\n            .persistent\n            .values()\n            .flatten()\n            .flat_map(|whistle| &amp;whistle.is_detected)\n        {\n            self.detection_buffer.push_front(is_detected);\n        }\n        self.detection_buffer.truncate(*context.buffer_length); // (9)\n\n        let number_of_detections = self\n            .detection_buffer\n            .iter()\n            .filter(|&amp;&amp;was_detected| was_detected)\n            .count();\n        let is_detected = number_of_detections &gt; *context.minimum_detections;\n        let started_this_cycle = is_detected &amp;&amp; !self.was_detected_last_cycle;\n        if started_this_cycle {\n            self.last_detection = Some(cycle_start_time);\n        }\n        self.was_detected_last_cycle = is_detected;\n\n        Ok(MainOutputs {\n            filtered_whistle: FilteredWhistle {\n                is_detected,\n                last_detection: self.last_detection,\n                started_this_cycle,\n            }\n            .into(),\n        }) //(10)\n    }\n}\n</code></pre> <ol> <li>Estados do n\u00f3.</li> <li>Contexto de cria\u00e7\u00e3o do n\u00f3. Mais informa\u00e7\u00f5es em Macros.</li> <li>Contexto de ciclo do n\u00f3. Mais informa\u00e7\u00f5es em Macros.</li> <li>Par\u00e2metros extra\u00eddos de <code>default.json</code>. Pode ser mudado em tempo de execu\u00e7\u00e3o utilizando o Twix.</li> <li>Input de outro n\u00f3, do tipo <code>CycleTime</code>.</li> <li>Input de outro n\u00f3, mas com dados persistentes e transientes.</li> <li>Ser\u00e1 chamado na cria\u00e7\u00e3o do n\u00f3. Basicamente, \u00e9 o construtor do n\u00f3.</li> <li>Ser\u00e1 chamado a cada ciclo. \u00c9 a fun\u00e7\u00e3o principal do n\u00f3.</li> <li>Par\u00e2metro declarado pelo usu\u00e1rio. Ent\u00e3o tem de ser uma refer\u00eancia. Aqui o par\u00e2metro \u00e9 desreferenciado para ser utilizado.</li> <li>Retorna os outputs do n\u00f3. O <code>into()</code> \u00e9 utilizado para converter o tipo <code>FilteredWhistle</code> para <code>MainOutput&lt;FilteredWhistle&gt;</code>.</li> </ol>"},{"location":"framework/nodes/#template-de-no","title":"Template de n\u00f3","text":"<p>N\u00e3o \u00e9 uma regra fixa, mas esse template engloba o b\u00e1sico de um n\u00f3. Ajuste conforme necess\u00e1rio.</p> <pre><code>use color_eyre::Result; // (1)\nuse context_attribute::context;\nuse framework::MainOutput;\nuse serde::{Serialize, Deserialize};\n\n#[derive(Default, Serialize, Deserialize)]\npub struct ExampleNode {\n    // (2) \n}\n\n#[context]\n#[derive(Default)]\npub struct MainOutputs {\n    pub some_output: MainOutput&lt;u32&gt;, // (3)\n}\n\n#[context]\npub struct CreationContext {\n    // (4)\n}\n\n#[context]\npub struct CycleContext {\n    // (5)\n}\n\nimpl ExampleNode {\n    pub fn new(_context: CreationContext) -&gt; Result&lt;Self&gt; {\n        Ok(Self::default())\n    }\n\n    pub fn cycle(&amp;mut self, _context: CycleContext) -&gt; Result&lt;MainOutputs&gt; {\n        // Processamento do node\n        let valor_processado = 42;\n\n        // Retorna as sa\u00eddas principais\n        Ok(MainOutputs {\n            some_output: valor_processado.into(), // (6)\n        })\n    }\n}\n</code></pre> <ol> <li>Biblioteca para tratamento e formata\u00e7\u00e3o de erros.</li> <li>Estados do n\u00f3.</li> <li>Outputs do n\u00f3. O <code>MainOutput</code> \u00e9 um tipo especial da framework que permite a convers\u00e3o de tipos.</li> <li>Contexto de cria\u00e7\u00e3o do n\u00f3, conjunto de depend\u00eancias e par\u00e2metros fornecidos ao node quando ele \u00e9 criado.</li> <li>Contexto de ciclo do n\u00f3, carrega os dados (inputs, par\u00e2metros etc.) recebidos a cada itera\u00e7\u00e3o do node.</li> <li>Retorna os outputs do n\u00f3. O <code>into()</code> \u00e9 utilizado para converter o tipo <code>u32</code> para <code>MainOutput&lt;u32&gt;</code>. J\u00e1 o <code>Ok()</code> \u00e9 utilizado para retornar um resultado de sucesso.</li> </ol>"},{"location":"framework/parameters/","title":"Par\u00e2metros","text":"<p>O software de controle rob\u00f3tico tem algums par\u00e2metros de configura\u00e7\u00e3o que afetam c\u00e1lculos e a execu\u00e7\u00e3o do c\u00f3digo.</p>"},{"location":"framework/parameters/#carregando-e-modificacoes","title":"Carregando e Modifica\u00e7\u00f5es","text":"<p>Os par\u00e2metros s\u00e3o carregados pelo sistema de arquivos. Esses arquivos est\u00e3o localizados em <code>etc/parameters/</code>. Este diret\u00f3rio tamb\u00e9m \u00e9 mandado por deploy para o NAO. A Comunica\u00e7\u00e3o \u00e9 capaz de modificar valores dos par\u00e2metros em tempo de execu\u00e7\u00e3o (mas n\u00e3o consegue aplicar essa modifica\u00e7\u00f5es no arquivo propriamente dito).</p>"},{"location":"framework/parameters/#sobrescrevendo","title":"Sobrescrevendo","text":"<p>O diret\u00f3rio dos par\u00e2metros permite sobrescrever individualmente campos de configura\u00e7\u00f5es na hierarquia dos objetos. Os NAOs tem as c\u00e2meras e a placa principal na cabe\u00e7a, e a placa do peito e atuadores espalhados pelo corpo. Cada cabe\u00e7a e corpo do NAO possui um ID \u00fanico que permite carregar par\u00e2metros espec\u00edficos. Al\u00e9m disso, rob\u00f4s podem precisar de diferentes par\u00e2metros dependendo da localiza\u00e7\u00e3o, essa localiza\u00e7\u00e3o \u00e9 selecionada no diret\u00f3rio <code>etc/parameters/</code> e aponta para um diret\u00f3rio em que os arquivos de par\u00e2metros sobrescritos s\u00e3o colocados. Para criar um objeto de par\u00e2metros completo \u00e9 necess\u00e1rio utilizar este procedimento:  </p> <ol> <li>Ler e processar (parsing) <code>etc/configuration/default.json</code> </li> <li>Se existir, ler e processar...  <ul> <li>Para o NAO: <code>etc/nao_location/default.json</code> </li> <li>Para Webots: <code>etc/webots_location/default.json</code> </li> <li>Para o simulador de comportamento: <code>etc/simulated_location/default.json</code> </li> </ul> </li> <li>Se existir, ler e processar <code>etc/body.{body_id}.json</code> </li> <li>Se existir, ler e processar <code>etc/head.{body_id}.json</code> </li> <li>Se existir, ler e processar...  <ul> <li>Para o NAO: <code>etc/nao_location/body.{body_id}.json</code> </li> <li>Para Webots: <code>etc/webots_location/body.{body_id}.json</code> </li> <li>Para o simulador de comportamento: <code>etc/simulated_location/body.{body_id}.json</code> </li> </ul> </li> <li>Se existir, ler e processar...  <ul> <li>Para o NAO: <code>etc/nao_location/head.{body_id}.json</code> </li> <li>Para Webots: <code>etc/webots_location/head.{body_id}.json</code> </li> <li>Para o simulador de comportamento: <code>etc/simulated_location/head.{body_id}.json</code> </li> </ul> </li> </ol> <p>Os locais dos diret\u00f3rios geralmente s\u00e3o symlinks para os diret\u00f3rios verdadeiros. Isso permite mudar locais facilmente redirecionando os symlinks. </p>"},{"location":"framework/runtime/","title":"Runtime","text":"<p>O Runtime, ou tempo de execu\u00e7\u00e3o, \u00e9 o componente do software que encapsula todos os subcomponentes, como interface de hardware, comunica\u00e7\u00e3o, e execu\u00e7\u00e3o de n\u00f3s. Aqui est\u00e1 uma imagem mais detalhada do que o Runtime faz:   </p> <p></p> <p>Essa se\u00e7\u00e3o e as subsequentes v\u00e3o explicar esse diagrama com mais detalhes. Muitas conex\u00f5es do fluxo de dados n\u00e3o est\u00e3o representadas para facilitar a compreens\u00e3o da imagem.</p> <p>O Runtime \u00e9 constru\u00eddo com uma interface de hardware j\u00e1 criada e inicializada pelo c\u00f3digo. Ela cont\u00e9m todos os subcomponentes e por isso \u00e9 respons\u00e1vel por construir e inicializar eles. Subcomponentes precisam ser interconectados entre si. Dessa forma, o runtime cria todos os canais de comunica\u00e7\u00e3o necess\u00e1rios, al\u00e9m dos buffers que s\u00e3o compartilhados entre os subcomponentes. Mais detalhes sobre comunica\u00e7\u00e3o enter cyclers e comunica\u00e7\u00e3o no geral s\u00e3o fornecidas em Comunica\u00e7\u00e3o.</p>"},{"location":"framework/thread-communication/","title":"Comunica\u00e7\u00e3o entre Threads","text":"<p>Documenta\u00e7\u00e3o detalhada ainda n\u00e3o fornecida pela HULKs</p>"},{"location":"framework/thread-communication/#todo-elaborar","title":"TODO: Elaborar","text":"<ul> <li>Buffering/Comunica\u00e7\u00e3o entre Threads/Canais<ul> <li>Tokio CancellationToken</li> <li>n-tuple Buffer<ul> <li>Rela\u00e7\u00e3o com Triple Buffer</li> <li>Guarantees, Assumptions</li> </ul> </li> <li>Canais Tokio</li> <li>Diagrama de comunica\u00e7\u00e3o dos canais (primeiramente Cycler&lt;-&gt;Cycler e Cycler&lt;-&gt;Communication)</li> </ul> </li> </ul>"},{"location":"robotica/","title":"Indice","text":"<p>Esta se\u00e7\u00e3o visa explicar como o c\u00f3digo funciona no NAO de maneira mais abstrata e geral, j\u00e1 tendo explicado os m\u00f3dulos fornecidos pela framework.</p>"},{"location":"robotica/#cyclers","title":"Cyclers","text":"<p>Atualmente existem seis threads rodando no NAO, em jarg\u00e3o de Tamboerijn (e HULKs) s\u00e3o chamados de <code>cyclers</code>:</p> <ul> <li><code>Control</code></li> <li><code>VisionTop</code></li> <li><code>VisionBottom</code></li> <li><code>Audio</code></li> <li><code>SPLNetwork</code></li> <li><code>ObjectDetectionTop</code></li> </ul> <p>De forma resumida elas s\u00e3o respons\u00e1veis por:</p>"},{"location":"robotica/#controle","title":"Controle","text":"<p>Este Cycler \u00e9 respons\u00e1vel pelo controle alto-n\u00edvel do rob\u00f4, isso inclui tasks relacionadas \u00e0 comportamento, sele\u00e7\u00e3o de a\u00e7\u00f5es para execu\u00e7\u00e3o, relacionadas \u00e0 movimenta\u00e7\u00e3o como execu\u00e7\u00e3o de a\u00e7\u00f5es selecionadas como driblar, chutar, ficar em p\u00e9, entre outras. A thread de controle roda com maior prioridade que as outras com uma frequ\u00eancia maior de 83 Hz, ou seja, a cada 12 ms. Se estiver mais curioso da uma fu\u00e7ada no c\u00f3digo, nos diret\u00f3rios de <code>behavior</code> na crate <code>control</code></p>"},{"location":"robotica/#visiontop-e-visionbottom","title":"VisionTop e VisionBottom","text":"<p>Esses dois Cyclers processam as imagens das c\u00e2meras do NAO, a <code>VisionTop</code> processa a imagem da c\u00e2mera superior e a <code>VisionBottom</code> a inferior. Isso inclui segmenta\u00e7\u00e3o de imagem, detec\u00e7\u00e3o de bola, de linhas, entre outros. Ambos rodam a 30 Hz (a frequ\u00eancia das c\u00e2meras), ou seja, a cada 33 ms.</p>"},{"location":"robotica/#audio","title":"Audio","text":"<p>Esse Cycler \u00e9 respons\u00e1vel por processar o \u00e1udio captado pelos microfones do NAO, ou seja, a detec\u00e7\u00e3o de apito.</p>"},{"location":"robotica/#splnetwork","title":"SPLNetwork","text":"<p>Essa thread lida com todas mensagens recebidas e enviadas pela rede SPL, ent\u00e3o, \u00e9 respons\u00e1vel pela comunica\u00e7\u00e3o com o GameController e com os outros rob\u00f4s do time.</p>"},{"location":"robotica/#objectdetectiontop","title":"ObjectDetectionTop","text":"<p>Esse Cycler ainda n\u00e3o \u00e9 presente no Tamboerijn, mas \u00e9 presente no c\u00f3digo da HULKs. Ele \u00e9 respons\u00e1vel por detectar gestos do \u00e1rbitro. Nossa liga ainda n\u00e3o utiliza essa funcionalidade, mas futuramente pode ser necess\u00e1rio implementar.</p>"},{"location":"robotica/#podemos-dividir-a-robotica-em-tres-areas-principais","title":"Podemos dividir a rob\u00f3tica em tr\u00eas \u00e1reas principais","text":"<p>Na Rino estruturamos de uma forma um pouco diferente da HULKs, ent\u00e3o existem disparidades entre este documento e o oficial da equipe alem\u00e3.</p>"},{"location":"robotica/#sensoriamento","title":"Sensoriamento","text":"<p>Como o rob\u00f4 percebe o mundo ao seu redor. No caso do NAO, temos c\u00e2meras, microfones, sensores de toque, ultrassom,girosc\u00f3pios, aceler\u00f4metros, etc. Essa \u00e1rea \u00e9 respons\u00e1vel por:</p> <ul> <li>Filtragem</li> <li>Vis\u00e3o</li> <li>\u00c1udio</li> </ul>"},{"location":"robotica/#comportamento-e-estrategia","title":"Comportamento e Estrat\u00e9gia","text":"<p>Como o rob\u00f4 decide o que fazer, comunica\u00e7\u00e3o com GameController (SPLNetwork) e time, e <code>roles</code> (pap\u00e9is) dos rob\u00f4s em campo.  </p> <ul> <li>Comportamento</li> <li>SPL Network</li> </ul>"},{"location":"robotica/#movimentacao","title":"Movimenta\u00e7\u00e3o","text":"<p>Toda a parte f\u00edsica do rob\u00f4, como modelo matem\u00e1tico, planejamento de passos, caminhar, chutar, etc.</p> <ul> <li>Planejamento de Passos</li> <li>Caminhar</li> <li>Chutar</li> <li>Motion Files</li> </ul>"},{"location":"robotica/comportamento/comportamento/","title":"Comportamento","text":"<p>O comportamento do rob\u00f4 \u00e9 controlado pelo n\u00f3 <code>node</code>. Nele \u00e9 decidido quais a\u00e7\u00f5es ser\u00e3o tomadas. Essa organiza\u00e7\u00e3o \u00e9 feita em dois passos:</p>"},{"location":"robotica/comportamento/comportamento/#coleta-de-acoes","title":"Coleta de A\u00e7\u00f5es","text":"<p>Nesse passo, o estado do <code>world</code> e outros inputs s\u00e3o utilizados para criar uma lista ordenada por prioridade de a\u00e7\u00f5es que o rob\u00f4 gostaria de tomar. Exemplos:  </p> <pre><code>let mut actions = vec![\n            Action::Unstiff,\n            Action::SitDown,\n            Action::Penalize,\n            Action::Initial,\n            Action::FallSafely,\n            Action::StandUp,\n        ];\n</code></pre> <p>Dependendo da situa\u00e7\u00e3o atual, diferentes a\u00e7\u00f5es podem ser adicionadas \u00e0 lista caso necess\u00e1rio:</p> <p>Se a role atual \u00e9 de Goleiro e uma cobran\u00e7a de p\u00eanalte est\u00e1 acontecendo, as a\u00e7\u00f5es <code>Jump</code> e <code>PrepareJump</code> s\u00e3o adicionadas \u00e0 lista </p> <pre><code>match world_state.robot.role {\n        Role::Keeper =&gt; match world_state.filtered_game_controller_state {\n            Some(FilteredGameControllerState {\n                game_phase: GamePhase::PenaltyShootout { .. },\n                ..\n            }) =&gt; {\n                actions.push(Action::Jump);\n                actions.push(Action::PrepareJump);\n            }\n            _ =&gt; actions.push(Action::DefendGoal),\n        },\n</code></pre>"},{"location":"robotica/comportamento/comportamento/#selecao-de-acao","title":"Sele\u00e7\u00e3o de A\u00e7\u00e3o","text":"<p>Agora, a lista \u00e9 iterada at\u00e9 que uma a\u00e7\u00e3o, que \u00e9 execut\u00e1vel no momento, \u00e9 encontrada. Essa a\u00e7\u00e3o retorna um <code>motion_command</code>, que \u00e9 enviado para o <code>motion_selection</code> no Cycler de Motion.  </p>"},{"location":"robotica/comportamento/estados_do_robo/","title":"Estados do Rob\u00f4","text":"<p>Pelo rulebook do SPL, o rob\u00f4 pode assumir 9 estados prim\u00e1rios diferentes (veja o diagrama abaixo). Deve haver conex\u00e3o WiFi para que os estados sejam alterados pelo Game Controller. E cabe \u00e0 \u00e1rea de comportamento e estrat\u00e9gia do time implementar a l\u00f3gica de resposta ao Game Controller e a transi\u00e7\u00e3o de estados propriamente dita no NAO.</p>"},{"location":"robotica/comportamento/estados_do_robo/#diagrama-de-estados","title":"Diagrama de Estados","text":"<ul> <li>As setas cinzas representam a transi\u00e7\u00e3o de estados que \u00e9 feita pelo bot\u00e3o do peito do rob\u00f4. Por\u00e9m, todos os estados podem ser mudados pelo Game Controller.  </li> <li>As setas pretas representam a transi\u00e7\u00e3o de estados que \u00e9 feita somente pelo Game Controller.  </li> <li>A seta azul mostra que qualquer estado pode ser transicionado para <code>unstiff</code>.  </li> <li>A seta roxa mostra que somente o estado <code>initial</code> pode ser transicionado para <code>calibration</code>.  </li> </ul>"},{"location":"robotica/comportamento/estados_do_robo/#estados-primarios","title":"Estados Prim\u00e1rios","text":"<p>Este t\u00f3pico descreve os estados prim\u00e1rios do rob\u00f4, a principal l\u00f3gica delas e as regras que os regem.</p> <p>Os estados prim\u00e1rios ditados pela Robocup s\u00e3o estes abaixo. Importante ressaltar que o LED do bot\u00e3o do peito deve mudar de cor indicando o estado atual do rob\u00f4.</p> <ol> <li><code>unstiff</code>: N\u00e3o r\u00edgido, estado em que todos os motores est\u00e3o ligados, mas sem nenhuma rigidez. O rob\u00f4 deve retornar \u00e0 posi\u00e7\u00e3o sentado e com as juntas relaxadas. Deve ser feito quando os 3 sensores de toque da cabe\u00e7a s\u00e3o pressionados simultaneamente. Neste estado, os LEDs do peito devem estar piscando azuis.</li> <li><code>initial</code>: Inicial, os rob\u00f4s est\u00e3o livres para se mover de acordo com a vontade do time, e humanos podem interagir com eles. Neste estado, n\u00e3o h\u00e1 limite de tempo, e os times t\u00eam acesso ao campo. O Game Controller vai ativar este estado antes do <code>standby</code>. Apertar o bot\u00e3o do peito deve trocar de estado para <code>penalized</code>. Os LEDs devem estar desligados.</li> <li><code>standby</code>: Em espera, os rob\u00f4s n\u00e3o podem se mover em qualquer modo, exceto para se levantar e mexer a cabe\u00e7a. Neste estado, os rob\u00f4s est\u00e3o esperando um sinal visual do juiz para come\u00e7ar o jogo. Este estado s\u00f3 \u00e9 usado na Champions Cup, e n\u00f3s, da Challengers Shield, n\u00e3o precisamos de nos preocupar por enquanto. Para n\u00f3s o rob\u00f4 pula para o estado <code>ready</code>. Os LEDs devem estar fixo em ciano.</li> <li><code>ready</code>: Pronto, os rob\u00f4s devem andar at\u00e9 suas posi\u00e7\u00f5es legais para o chute inicial ou cobran\u00e7a de p\u00eanalti. Eles permanecem neste estado at\u00e9 que o juiz principal d\u00ea o sinal para come\u00e7ar o jogo ou at\u00e9 45 segundos se passarem (30 segundos em caso de p\u00eanalti). LEDs fixos em azul.</li> <li><code>set</code>: Preparado. Neste estado, os rob\u00f4s param e esperam pelo chute inicial ou cobran\u00e7a de p\u00eanalti. Rob\u00f4s em posi\u00e7\u00e3o ilegal s\u00e3o penalizados (estado deve mudar para <code>penalized</code>) e colocados na borda do campo. Os jogadores podem se mover para se levantar caso caiam no caminho para a posi\u00e7\u00e3o correta. Por\u00e9m, n\u00e3o podem se locomover de outra maneira. Caso n\u00e3o se levantem, ser\u00e3o retirados do campo. LEDs devem estar fixos em amarelo.</li> <li><code>playing</code>: Jogando. Os rob\u00f4s est\u00e3o jogando a partida. Apertar o peito deve transicionar para <code>penalized</code>.LEDs devem estar fixos em verde.  </li> <li><code>penalized</code>: Penalizado. O rob\u00f4 foi penalizado e deve ficar parado por um tempo determinado pelo juiz. Os \u00fanicos movimentos permitidos s\u00e3o os respons\u00e1veis por levantar o rob\u00f4 em caso de queda. Qualquer outro movimento, inclusive mexer a cabe\u00e7a, s\u00e3o ilegais. Apertar o peito novamente deve retornar ao estado de <code>playing</code>. LEDs devem estar fixos em vermelho.</li> <li><code>finished</code>: Finalizado. Quando um tempo de jogo ou a partida termina. Comportamento n\u00e3o especificado. LEDs devem estar desligados.</li> <li><code>calibration</code>: Calibra\u00e7\u00e3o. Estado em que o rob\u00f4 est\u00e1 calibrando seus sensores. Deve ser disponivel para a transi\u00e7\u00e3o apenas se o estado atual for <code>initial</code>. Deve ser acessado apertando o bot\u00e3o frontal da cabe\u00e7a. LEDs devem estar fixos em roxo.</li> </ol> <p>Alguns estados podem ser transicionados a partir de apitos do juiz. Conferir o livro de regras para ver quais e como se aplicam, pois \u00e9 comum mudarem.</p>"},{"location":"robotica/comportamento/roles/","title":"Roles","text":"<p>Este documento descreve as Roles, que s\u00e3o os pap\u00e9is que um rob\u00f4 pode assumir em um jogo, como elas s\u00e3o definidas e como modificar o comportamento delas. Elas s\u00e3o aplicadas somente em tempo de execu\u00e7\u00e3o, diferente da Mari em que s\u00e3o definidas em tempo de compila\u00e7\u00e3o num arquivo JSON.  </p> <p>\u00c9 importante ressaltar que as Roles s\u00e3o din\u00e2micas e mudam de acordo com o estado do jogo, posi\u00e7\u00e3o dos rob\u00f4s, proximidade da bola, etc.</p>"},{"location":"robotica/comportamento/roles/#enum-roles","title":"Enum <code>Roles</code>","text":"<p>A enumera\u00e7\u00e3o <code>Roles</code> \u00e9 um conjunto de constantes que representam os pap\u00e9is que um rob\u00f4 pode assumir. Pode ser encontrada na crate <code>/crates/types/src/roles.rs</code>. O rob\u00f4 pode assumir um destes pap\u00e9is:</p> <pre><code>pub enum Role {\n    DefenderLeft,\n    DefenderRight,\n    Keeper,\n    Loser,\n    MidfielderLeft,\n    MidfielderRight,\n    ReplacementKeeper,\n    Searcher,\n    #[default]\n    Striker,\n    StrikerSupporter,\n}\n</code></pre>"},{"location":"robotica/comportamento/roles/#funcoes-das-roles","title":"Fun\u00e7\u00f5es das Roles","text":"<ul> <li>Striker (Atacante): Assume a posse efetiva da bola, conduzindo chutes e jogadas ofensivas. O rob\u00f4 se torna Striker se detectar/possuir a bola e n\u00e3o houver outro Striker oficial, ou caso <code>forced_role</code> imponha isso.</li> <li>Loser (Perdedor): Entra nesse estado quando o Striker perde a bola: por exemplo, o rob\u00f4 era Striker, mas percebeu que n\u00e3o tem mais a bola ou recebeu mensagem informando perda de posse.</li> <li>Searcher (Buscador): Usa estrat\u00e9gias de busca para procurar a bola no campo. O rob\u00f4 assume Searcher quando n\u00e3o h\u00e1 posse clara da bola, e nenhuma outra fun\u00e7\u00e3o de ataque ou posse foi definida. Informa a posi\u00e7\u00e3o da bola para os outros rob\u00f4s caso encontre.</li> <li>Keeper (Goleiro): Protege o gol, principalmente em jogadas de ataque do advers\u00e1rio. \u00c9 definido prioritariamente quando a partida indica que o time advers\u00e1rio est\u00e1 chutando ou se <code>forced_role</code> exigir.</li> <li>ReplacementKeeper (Goleiro Reserva): Substitui o Keeper quando esse est\u00e1 penalizado ou sofre alguma imposi\u00e7\u00e3o. Ativo apenas se a l\u00f3gica de distribui\u00e7\u00f5es de Roles n\u00e3o colocar outro rob\u00f4 como Keeper principal.</li> <li>DefenderLeft (Defensor Esquerdo) / DefenderRight (Defensor Direito): Defendem zonas espec\u00edficas (lateral esquerda ou direita). S\u00e3o atribu\u00eddos quando o time est\u00e1 em postura defensiva e n\u00e3o h\u00e1 necessidade de Keeper adicional.</li> <li>MidfielderLeft (Meio-Campo Esquerdo) / MidfielderRight (Meio-Campo Direito): Ocupam fun\u00e7\u00f5es intermedi\u00e1rias, auxiliando tanto na defesa quanto no ataque, de acordo com as necessidades do time (por exemplo, suprindo aus\u00eancia de Striker ou Loser).</li> <li>StrikerSupporter (Apoio ao Atacante): Ajuda o Striker principal, mas n\u00e3o disputa diretamente a bola. Geralmente escolhido quando h\u00e1 mais de um jogador dispon\u00edvel para auxiliar na jogada ofensiva.</li> </ul>"},{"location":"robotica/comportamento/roles/#definindo-as-roles","title":"Definindo as Roles","text":"<p>H\u00e1 uma <code>struct</code> chamada <code>RoleAssignment</code> que \u00e9 respons\u00e1vel por definir as roles dos rob\u00f4s, controlar o estado atual do Role do jogador e outras informa\u00e7\u00f5es (por exemplo, quando foi a \u00faltima transmiss\u00e3o de mensagem). O m\u00e9todo cycle decide se o Role deve mudar, checando se \u00e9 preciso inicializar a fun\u00e7\u00e3o, se h\u00e1 for\u00e7amento de Role ou se \u00e9 hora de enviar mensagens de rede.</p> <p>Dentro de cycle, chama-se <code>process_role_state_machine</code>, que cont\u00e9m a l\u00f3gica principal para troca de pap\u00e9is, verificando:</p> <ol> <li>Se a bola foi perdida (e o jogador \u00e9 Striker), podendo virar Loser.</li> <li>Se outro jogador j\u00e1 reivindicou Striker.</li> <li>Se o jogador conseguiu a bola, mudando de Loser para Striker (ou de Searcher para Striker).</li> <li>Se h\u00e1 algum Role for\u00e7ado via forced_role.</li> <li>Outras verifica\u00e7\u00f5es espec\u00edficas para cada Role.</li> </ol>"},{"location":"robotica/comportamento/roles/#definindo-roles-forcadas","title":"Definindo Roles For\u00e7adas","text":"<p>Se <code>forced_role</code> estiver configurado, o jogador assume essa fun\u00e7\u00e3o imediatamente, sem depender das l\u00f3gicas internas de detec\u00e7\u00e3o ou do estado do jogo:</p> <pre><code>// ...existing code...\nif let Some(forced_role) = context.forced_role {\n    self.role = *forced_role;\n} else {\n    self.role = role;\n}\n// ...existing code...\n</code></pre>"},{"location":"robotica/comportamento/spl-network/","title":"SPL Network","text":"<p>Este documento visa a descrever o funcionamento da rede do SPL, da comunica\u00e7\u00e3o com Game Controller e futuramente entre rob\u00f4s.</p>"},{"location":"robotica/comportamento/spl-network/#game-controller","title":"Game Controller","text":"<p>Atualmente, toda a comunica\u00e7\u00e3o do SPL ocorre por IPv4, mas a maior parte tamb\u00e9m \u00e9 compat\u00edvel com IPv6.  </p> <p>Todo o tutorial de instala\u00e7\u00e3o e utiliza\u00e7\u00e3o do GameController est\u00e1 no reposit\u00f3rio. Este documento explica o funcionamento e as especifica\u00e7\u00f5es da comunica\u00e7\u00e3o.</p> <p>A fun\u00e7\u00e3o deste programa \u00e9 agir como \u00e1rbitro da partida, registrando eventos, gols, penalidades, etc. Ele tamb\u00e9m \u00e9 respons\u00e1vel por enviar mensagens de controle para os rob\u00f4s, como in\u00edcio e fim de jogo, mudan\u00e7as de estados (mais detalhes em Estados do Rob\u00f4), al\u00e9m de receber mensagens de status dos jogadores. O Game Controller comunica com os jogadores por tr\u00eas canais:</p> <ul> <li>Manda messagens de controle na frequ\u00eancia de 2Hz (transmiss\u00e3o UDP pela porta 3838, num formato especificado pela struct <code>RoboCupGameControlData</code> no c\u00f3digo fonte do GC). Essas mensagens de controle nem sempre representam o estado atual do jogo, especialmente depois de um gol, ou a transi\u00e7\u00e3o para o estado <code>playing</code>. Depois destes eventos o estado anterior \u00e9 mantido por at\u00e9 15 segundos, ou at\u00e9 outro evento que n\u00e3o poderia ocorrer neste estado \"falso\".</li> <li>Recebe mensagens de status dos jogadores no intervalo de frequ\u00eancia de 0.5Hz at\u00e9 2Hz (UDP Unicast na porta 3939, formato especificado pela struct <code>RoboCupGameControlReturnData</code>).</li> <li>Recebe mensagens de time dos rob\u00f4s (UDP Broadcast porta 10000 + n\u00famero do time, at\u00e9 128 bytes de payload com formato arbitr\u00e1rio).</li> </ul>"},{"location":"robotica/comportamento/spl-network/#comunicacao-geral","title":"Comunica\u00e7\u00e3o Geral","text":"<p>Esse t\u00f3pico \u00e9 baseado no livro de regras do SPL 2024. Membros devem se manter informados para poss\u00edveis mudan\u00e7as.</p> <p>Como citado anteriormente, a comunica\u00e7\u00e3o entre os rob\u00f4s \u00e9 feita por IPv4 e IPv6. A estrutura do IP segue o padr\u00e3o <code>10.&lt;interface&gt;.&lt;time&gt;.&lt;n\u00famero&gt;</code> com a interface sendo 0 para WiFi e 1 para Ethernet. O n\u00famero do time \u00e9 47, e o n\u00famero do rob\u00f4 varia de acordo com o jogador. Ent\u00e3o, por exemplo, o rob\u00f4 13 da Rinobot comunicando via WiFi teria o IP <code>10.0.47.13</code>. O n\u00famero do rob\u00f4 \u00e9 configurado na gera\u00e7\u00e3o da imagem do Rob\u00f4, no arquivo <code>meta-hulks/recipes-hulks/network-config/network-config/id_map.json</code>.</p> <p>H\u00e1 um limite de 1200 pacotes UDP que podem ser transmitidos durante o jogo. Esse limite \u00e9 aumentado em 60 para cada minuto de acr\u00e9scimo do jogo. H\u00e1 penalidades para o time que exceder o limite.</p>"},{"location":"robotica/comportamento/spl-network/#comunicacao-entre-robos","title":"Comunica\u00e7\u00e3o entre Rob\u00f4s","text":"<p>TODO</p>"},{"location":"robotica/movimentacao/","title":"Resumo","text":"<p>Neste arquivo apresentamos de forma simplificada como o Tamboerijn lida com movimenta\u00e7\u00e3o. Esse esquema de 3 passos n\u00e3o ocorre na pr\u00e1tica, no c\u00f3digo \u00e9 tudo de uma vez, mas \u00e9 uma forma de entender como o rob\u00f4 se movimenta.  </p>"},{"location":"robotica/movimentacao/#selecao-da-movimentacao","title":"Sele\u00e7\u00e3o da Movimenta\u00e7\u00e3o","text":"<p>A movimenta\u00e7\u00e3o come\u00e7a no <code>motion_selector</code> encadeado a partir da resposta do comportamento, o <code>motion_command</code>. Aqui a movimenta\u00e7\u00e3o atual \u00e9 escolhida baseada na movimenta\u00e7\u00e3o anterior, se ela j\u00e1 acabou ou precisa ser abortada.  </p>"},{"location":"robotica/movimentacao/#execucao-da-movimentacao","title":"Execu\u00e7\u00e3o da Movimenta\u00e7\u00e3o","text":"<p>No pr\u00f3ximo passo, todos os n\u00f3s de todas as motions s\u00e3o executados. Os n\u00f3s, que as motions n\u00e3o foram selecionadas, s\u00e3o retirados previamente.  </p>"},{"location":"robotica/movimentacao/#envio-de-comandos","title":"Envio de Comandos","text":"<p>A movimenta\u00e7\u00e3o finaliza coletando todos os comandos dos motores na struct <code>motor_commands_collector</code>, envia eles para a <code>motor_commands_optimizer</code> e depois os escreve na interface de hardware no <code>command_sender</code>.</p>"},{"location":"robotica/movimentacao/caminhar/","title":"Caminhar","text":"<p>O processo de caminhar do rob\u00f4 \u00e9 dividido em 3 etapas:  </p> <ol> <li>O step planner calcula os passos que o rob\u00f4 deve dar. Isso inclui coordenadas x, y, z e rota\u00e7\u00e3o dependendo do <code>motion_command</code>.  </li> <li>O walk manager usa o passo calculado anteriormente e o <code>motion_command</code> para criar o <code>walk_command</code>, que define o modo de caminhar, como ficar em p\u00e9, andar para frente, para tr\u00e1s, etc.  </li> <li>A walking engine recebe o <code>walk_command</code> e o passo calculado e computa de acordo com os comandos de motores.  </li> </ol>"},{"location":"robotica/movimentacao/caminhar/#walking-engine","title":"Walking Engine","text":"<p>O n\u00facleo da Engine de Caminhada \u00e9 baseado no trabalho de Bernhard Hengst da UNSW Sydney, que \u00e9 padr\u00e3o na liga. A idea por tr\u00e1s \u00e9 bem simples:</p> <ol> <li>H\u00e1 dois p\u00e9s, o p\u00e9 de suporte e o p\u00e9 de balan\u00e7o.  </li> <li>Mova o p\u00e9 de balan\u00e7o para frente na velocidade x\u00b2.  </li> <li>Mova o p\u00e9 de suporte para tr\u00e1s na velocidade x.</li> </ol> <p>Detalhes t\u00e9cnicos podem ser encontrados na p\u00e1gina do Step Planning.</p>"},{"location":"robotica/movimentacao/chutar/","title":"Chutar","text":"<p>TODO</p>"},{"location":"robotica/movimentacao/motion-files/","title":"Motion Files","text":"<p>TODO</p>"},{"location":"robotica/movimentacao/step-planning/","title":"Planejamento de Passos","text":"<p>O planejamento de passos gira em torno do motor de caminhada desenvolvido pelo Bernhard Hengst da UNSW Sydney, que se tornou padr\u00e3o da liga e \u00e9 um dos principais avan\u00e7os na rob\u00f3tica bipedal.</p> <p>O documento base na \u00edntegra pode ser encontrado aqui e uma continua\u00e7\u00e3o aqui. Esses artigos s\u00e3o bem t\u00e9cnicos, \u00e9 onde o filho chora e a m\u00e3e n\u00e3o v\u00ea.</p> <p>Este documento apresenda, de forma simplificada, o processo de planejamento de passos.</p>"},{"location":"robotica/movimentacao/step-planning/#metodologia","title":"Metodologia","text":""},{"location":"robotica/movimentacao/step-planning/#1-modelo-de-simulacao","title":"1: Modelo de simula\u00e7\u00e3o","text":"<ul> <li>O rob\u00f4 b\u00edpede \u00e9 modelado como um p\u00eandulo invertido.</li> <li>Vari\u00e1veis de estado: Deslocamento horizontal (<code>x</code>), velocidade horizontal (<code>x'</code>), posi\u00e7\u00e3o do p\u00e9 oscilante (<code>w</code>) e tempo de ciclo de caminhada (<code>t</code>).</li> <li>A\u00e7\u00f5es de controle: inclina\u00e7\u00e3o do tornozelo (posi\u00e7\u00e3o do piv\u00f4 no p\u00e9 de suporte) e deslocamento incremental do p\u00e9 oscilante.</li> </ul>"},{"location":"robotica/movimentacao/step-planning/#2-planejamento-de-passos","title":"2: Planejamento de passos","text":"<p>Fomaliza\u00e7\u00e3o via Processo de Decis\u00e3o de Markov (MDP): (S, A, T, R), onde:</p> <ul> <li><code>S</code>: conjunto de estados.</li> <li><code>A</code>: conjunto de a\u00e7\u00f5es.</li> <li><code>T</code>: fun\u00e7\u00e3o de transi\u00e7\u00e3o estoc\u00e1stica.</li> <li><code>R</code>: fun\u00e7\u00e3o de recompensa.</li> </ul> <p>Uso de Q-Learning para aprendizado de refor\u00e7o com fator de desconto <code>\u03b3 = 0.9</code> e taxa de aprendizado <code>\u03b1 = 0.05</code>.</p> <p>Recompensa <code>R</code> \u00e9 dada por:</p> <ul> <li>-1000 para estados fora dos limites permitidos.</li> <li>+1000 para alcan\u00e7ar o objetivo.</li> <li>-1 ou -10 para penalizar a\u00e7\u00f5es que movimentam motores.</li> </ul> <p>Estado estimado via filtro de Kalman utilizando os sensores de press\u00e3o dos p\u00e9s, IMU e encoder dos motores.</p>"},{"location":"robotica/movimentacao/step-planning/#e-importante-levar-em-consideracao-que-este-modelo-nao-considera-movimentos-coronais-laterais-ainda-nao-encontrei-como-eles-sao-modelados","title":"\u00c9 importante levar em considera\u00e7\u00e3o que este modelo n\u00e3o considera movimentos coronais (laterais). Ainda n\u00e3o encontrei como eles s\u00e3o modelados","text":""},{"location":"robotica/movimentacao/step-planning/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>No Tamboerijn, o m\u00f3dulo <code>walking_engine</code> da crate <code>control/motion</code> coordena e controla a movimenta\u00e7\u00e3o de andar, com base no modelo de simula\u00e7\u00e3o descrito acima, adicionando tamb\u00e9m a l\u00f3gica de movimenta\u00e7\u00e3o dos bra\u00e7os e ajustes de equil\u00edbrio e chutes.</p> <p>Aqui est\u00e3o os principais m\u00f3dulos e suas responsabilidades:</p>"},{"location":"robotica/movimentacao/step-planning/#enginers","title":"<code>engine.rs</code>","text":"<p>Define fun\u00e7\u00f5es principais de c\u00e1lculo, como <code>calculate_foot_to_robot</code>, para obter transforma\u00e7\u00f5es dos p\u00e9s no espa\u00e7o do rob\u00f4. Inclui fun\u00e7\u00f5es matem\u00e1ticas (ex.: <code>parabolic_return</code> e <code>parabolic_step</code>) que ajudam a modelar a caracter\u00edstica parab\u00f3lica do movimento.</p>"},{"location":"robotica/movimentacao/step-planning/#armsrs","title":"<code>arms.rs</code>","text":"<p>Gerencia a l\u00f3gica de movimenta\u00e7\u00e3o dos bra\u00e7os, com estados de Swing, PullingBack, PullingTight, etc. Usa interpoladores (<code>SplineInterpolator</code>, <code>TimedSpline</code>) para transi\u00e7\u00f5es suaves entre posturas (ex.: <code>pull_back_joints</code> e <code>pull_tight_joints</code>).</p>"},{"location":"robotica/movimentacao/step-planning/#walk_staters","title":"<code>walk_state.rs</code>","text":"<p>Define a m\u00e1quina de estados da caminhada (Standing, Starting, Walking, Kicking, etc.). A evolu\u00e7\u00e3o de cada estado depende do comando recebido (<code>Stand</code>, <code>Walk</code>, <code>Kick</code>) e do p\u00e9 de suporte (<code>Side</code>).</p>"},{"location":"robotica/movimentacao/step-planning/#kickingrs","title":"<code>kicking.rs</code>","text":"<p>Aplica ajustes nos \u00e2ngulos das pernas para executar o chute (<code>apply_joint_overrides</code>). Uso de JointOverride para interpolar valores conforme o tempo e a intensidade do chute.</p>"},{"location":"robotica/movimentacao/step-planning/#foot_offsetsrs","title":"<code>foot_offsets.rs</code>","text":"<p>Estrutura que guarda os offsets (compensa\u00e7\u00f5es) de cada p\u00e9 (<code>forward</code>, <code>left</code>). Fornece m\u00e9todos utilit\u00e1rios como <code>FootOffsets::zero()</code>. \u00c9 necess\u00e1rio por que todo o equil\u00edbrio e modelo do rob\u00f4 \u00e9 baseado no centro de massa, mas para realizar o movimento dos p\u00e9s \u00e9 necess\u00e1rio deslocar o ponto de refer\u00eancia.</p>"},{"location":"robotica/movimentacao/step-planning/#balancingrs","title":"<code>balancing.rs</code>","text":"<p>Implementa corre\u00e7\u00f5es de equil\u00edbrio, como <code>support_leg_gyro_balancing</code>, ajustando articula\u00e7\u00f5es do p\u00e9/tornozelo/quadril com base em medi\u00e7\u00f5es de girosc\u00f3pio. Inclui l\u00f3gica de ajuste de passo (como <code>step_adjustment</code>) que corrige a posi\u00e7\u00e3o dos p\u00e9s conforme o deslocamento do tronco.</p>"},{"location":"robotica/sensoriamento/audio/","title":"Audio","text":"<p>O NAO v6 possui 4 microfones, que est\u00e3o localizados na cabe\u00e7a. Eles suportam frequ\u00eancias de 100 at\u00e9 10.000 Hz. Se voc\u00ea for nerd o suficiente, pode dar uma olhada na documenta\u00e7\u00e3o oficial da Aldebaran.  </p> <p>O Cycler de audio s\u00f3 possui 2 n\u00f3s, para gravar \u00e1udio e detectar apitos.  </p>"},{"location":"robotica/sensoriamento/audio/#gravacao-de-audio","title":"Grava\u00e7\u00e3o de \u00e1udio","text":"<p>L\u00ea amostras de \u00e1udio do microfone de <code>MicrophoneInterface</code> e as armazena na database do Cycler de \u00e1udio.  </p>"},{"location":"robotica/sensoriamento/audio/#deteccao-de-apitos","title":"Detec\u00e7\u00e3o de apitos","text":"<p>Como diz o nome, detecta apitos. Similar ao futebol humano, os \u00e1rbitros usam apitos para sinalizar o in\u00edcio e o fim de uma partida. Mais detalhes est\u00e3o no livro de regras do SPL (sempre procure o mais atual).  </p> <p>De forma simplificada, o detector de apitos funciona comparando amostras de \u00e1udio pr\u00e9 gravadas com as amostras atuais. Se a diferen\u00e7a entre as amostras for menor que um limiar, o apito \u00e9 detectado. Ela utiliza FFT.  </p> <p>Um beijo para a NAO Devils que desenvolveu o detector de apitos e publicou um artigo.</p>"},{"location":"robotica/sensoriamento/ball-detection/","title":"Detec\u00e7\u00e3o de Bola","text":"<p>A Detec\u00e7\u00e3o de Bola \u00e9 uma parte de extrema import\u00e2ncia durante toda a extens\u00e3o do jogo, orientando o rob\u00f4 e o pr\u00f3pio c\u00f3digo em si. Para isso, utiliza a capta\u00e7\u00e3o e e interpreta\u00e7\u00e3o das imagens das c\u00e2meras superior e inferior presentes no NAO, coleta e processa as imagens, obtendo as informa\u00e7\u00f5es necess\u00e1rias para as outras estruturas de decis\u00e3o, como a Movimenta\u00e7\u00e3o e o Comportamento.</p> <p>Em um alto n\u00edvel, a detec\u00e7\u00e3o de bola segue as seguintes etapas:  </p> <ul> <li>Detec\u00e7\u00e3o das imagens pelas cameras (<code>local</code>) e interpreta\u00e7\u00e3o das informa\u00e7\u00f5es nos formatos adequados</li> <li>Interpreta\u00e7\u00e3o e avalia\u00e7\u00e3o dos dados das imagens pelas redes neurais (<code>local</code>)</li> <li>Obten\u00e7\u00e3o da presen\u00e7a da bola e a sua localiza\u00e7\u00e3o</li> </ul> <p>A seguir, cada um dos pontos do processo de detec\u00e7\u00e3o ser\u00e1 analisada:</p>"},{"location":"robotica/sensoriamento/ball-detection/#estruturas","title":"Estruturas","text":""},{"location":"robotica/sensoriamento/ball-detection/#neuralnetworks","title":"NeuralNetworks","text":"<p>A estrutura NeuralNetworks cont\u00e9m tr\u00eas redes neurais compiladas: <code>preclassifier</code>, <code>classifier</code> e <code>positioner</code>. Estas redes neurais s\u00e3o usadas para classificar se uma determinada regi\u00e3o da imagem cont\u00e9m uma bola (preclassifier e classifier) e para determinar a posi\u00e7\u00e3o da bola na imagem (positioner).</p>"},{"location":"robotica/sensoriamento/ball-detection/#ballcluster","title":"BallCluster","text":"<p>A estrutura BallCluster \u00e9 usada para agrupar v\u00e1rias <code>CandidateEvaluation</code> que s\u00e3o consideradas parte da mesma bola. Ela cont\u00e9m um Circle que representa a localiza\u00e7\u00e3o e o tamanho da bola, e um vetor de refer\u00eancias para as <code>CandidateEvaluation</code> que s\u00e3o membros do cluster.</p>"},{"location":"robotica/sensoriamento/ball-detection/#estados-de-ciclo","title":"Estados de ciclo","text":"<p>As estruturas CreationContext, CycleContext e MainOutputs s\u00e3o usadas para gerenciar o estado e os par\u00e2metros do ciclo de detec\u00e7\u00e3o de bolas. CreationContext cont\u00e9m a interface de hardware e os par\u00e2metros de detec\u00e7\u00e3o de bolas. CycleContext cont\u00e9m v\u00e1rias entradas e par\u00e2metros necess\u00e1rios para um ciclo de detec\u00e7\u00e3o, incluindo os candidatos a bola, a matriz da c\u00e2mera, os candidatos da grade de perspectiva, a imagem e o raio da bola. MainOutputs cont\u00e9m a sa\u00edda principal do ciclo de detec\u00e7\u00e3o, que \u00e9 um vetor opcional de bolas detectadas.</p>"},{"location":"robotica/sensoriamento/ball-detection/#balldetection","title":"BallDetection","text":"<p>A estrutura BallDetection \u00e9 onde o processo da detec\u00e7\u00e3o de bola ocorre, com todas as partes praticas do procedimento. Ela \u00e9 definida com um campo neural_networks do tipo NeuralNetworks. Este campo \u00e9 marcado com o atributo  <code>#[serde(skip, default = \"deserialize_not_implemented\")]</code>, o que indica que ele deve ser ignorado durante a serializa\u00e7\u00e3o e deserializa\u00e7\u00e3o.</p> <p>A seguir, ser\u00e1 analisada cada uma das fun\u00e7\u00f5es presentes dentro da estrutura BallDetection:</p>"},{"location":"robotica/sensoriamento/ball-detection/#funcoes-dentro-da-estrutura-balldetection","title":"Fun\u00e7\u00f5es dentro da Estrutura BallDetection","text":"<p>Possui dois m\u00e9todos principais: <code>new</code> e <code>cycle</code>.</p>"},{"location":"robotica/sensoriamento/ball-detection/#new","title":"new","text":"<p>O m\u00e9todo <code>new</code> \u00e9 usado para criar uma nova inst\u00e2ncia de BallDetection. Ele compila tr\u00eas redes neurais: um pr\u00e9-classificador, um classificador e um posicionador, que s\u00e3o armazenados na estrutura NeuralNetworks. O m\u00e9todo do cycle \u00e9 a principal fun\u00e7\u00e3o que processa uma imagem para detectar bolas. \u00c9 necess\u00e1rio um CycleContext como entrada, que cont\u00e9m a imagem e outros par\u00e2metros necess\u00e1rios.</p>"},{"location":"robotica/sensoriamento/ball-detection/#cycle","title":"cycle","text":"<p>A fun\u00e7\u00e3o de <code>cycle</code> \u00e9 a principal fun\u00e7\u00e3o que orquestra o processo de detec\u00e7\u00e3o de bola. Come\u00e7a avaliando os candidatos para detec\u00e7\u00e3o de bola usando a fun\u00e7\u00e3o <code>evaluate_candidates</code>(colocar os endere\u00e7os para as funcoes mais abaixo). Os candidatos s\u00e3o ent\u00e3o filtrados com base no fato de terem um c\u00edrculo corrigido. Para cada bola detectada, um peso de mesclagem \u00e9 calculado usando a fun\u00e7\u00e3o <code>calcule_ball_merge_factor</code>(colocar os endere\u00e7os para as funcoes mais abaixo). As bolas s\u00e3o ent\u00e3o agrupadas usando a fun\u00e7\u00e3o <code>cluster_balls</code>(colocar os endere\u00e7os para as funcoes mais abaixo) e projetadas no solo usando a fun\u00e7\u00e3o <code>project_balls_to_ground</code>(colocar os endere\u00e7os para as funcoes mais abaixo). A fun\u00e7\u00e3o retorna as bolas detectadas.</p> <p>A seguir, se encontram as fun\u00e7\u00f5es executadas em repeti\u00e7\u00e3oo pela pr\u00f3rpia funcao <code>cycle</code>:</p>"},{"location":"robotica/sensoriamento/ball-detection/#evaluate_candidates","title":"evaluate_candidates","text":"<p>A fun\u00e7\u00e3o <code>evaluate_candidates</code> obt\u00e9m uma lista de c\u00edrculos candidatos (bolas potenciais), uma imagem e um conjunto de redes neurais. Ele amplia cada c\u00edrculo candidato, amostra a imagem dentro do c\u00edrculo ampliado e, em seguida, usa a rede neural pr\u00e9-classificadora <code>preclassifier</code> para avaliar a amostra. Se a confian\u00e7a do pr\u00e9-classificador estiver acima de um determinado limite, a rede neural do classificador <code>classifier</code> ser\u00e1 usada para avaliar melhor a amostra. Se a confian\u00e7a do classificador tamb\u00e9m estiver acima de um determinado limite, a rede neural do posicionador <code>positioner</code> \u00e9 usada para corrigir a posi\u00e7\u00e3o e o tamanho do c\u00edrculo. A fun\u00e7\u00e3o retorna uma lista de estruturas CandidateEvaluation, cada uma contendo um c\u00edrculo candidato, as confian\u00e7as do pr\u00e9-classificador e do classificador e o c\u00edrculo corrigido (se houver).</p>"},{"location":"robotica/sensoriamento/ball-detection/#calculate_ball_merge_factor","title":"calculate_ball_merge_factor","text":"<p>A fun\u00e7\u00e3o <code>calculate_ball_merge_factor</code> calcula um fator de mesclagem para uma bola, que \u00e9 usado para determinar se v\u00e1rias bolas devem ser mescladas em uma \u00fanica bola. O fator de mesclagem \u00e9 uma combina\u00e7\u00e3o da confian\u00e7a do classificador, da proximidade do c\u00edrculo corrigido ao c\u00edrculo candidato e de quanto do c\u00edrculo corrigido est\u00e1 contido na imagem.</p>"},{"location":"robotica/sensoriamento/ball-detection/#cluster_balls","title":"cluster_balls","text":"<p>A fun\u00e7\u00e3o <code>cluster_balls</code> recebe uma lista de bolas e um fator de raio de mesclagem. Ele agrupa as bolas com base na proximidade umas das outras. Se uma bola estiver dentro do raio de fus\u00e3o de um cluster, ela ser\u00e1 adicionada a esse cluster. Caso contr\u00e1rio, um novo cluster ser\u00e1 criado para aquela bola. A fun\u00e7\u00e3o retorna uma lista de estruturas BallCluster, cada uma contendo um c\u00edrculo representando a localiza\u00e7\u00e3o e o tamanho do cluster, e uma lista das bolas no cluster.</p>"},{"location":"robotica/sensoriamento/ball-detection/#project_balls_to_ground","title":"project_balls_to_ground","text":"<p>A fun\u00e7\u00e3o <code>project_balls_to_ground</code> obt\u00e9m uma lista de clusters de bolas, uma matriz de c\u00e2mera e um raio de bola. Ele projeta cada cluster do plano da imagem para o plano terrestre usando a matriz da c\u00e2mera e o raio da bola. A fun\u00e7\u00e3o retorna uma lista de estruturas Ball, cada uma contendo a posi\u00e7\u00e3o da bola no solo e a localiza\u00e7\u00e3o da bola na imagem.</p>"},{"location":"robotica/sensoriamento/ball-detection/#preclassify_sample-classify_sample-e-position_sample","title":"preclassify_sample, classify_sample e position_sample","text":"<p>As fun\u00e7\u00f5es <code>preclassify_sample</code>, <code>classify_sample</code> e <code>position_sample</code> usam uma refer\u00eancia mut\u00e1vel a uma CompiledNN (rede neural compilada) e uma refer\u00eancia a uma amostra como argumentos. Uma amostra aqui provavelmente \u00e9 uma pequena se\u00e7\u00e3o da imagem que est\u00e1 sendo processada.</p> <p>Em todas as tr\u00eas fun\u00e7\u00f5es, a amostra \u00e9 alimentada na rede neural. Isso \u00e9 feito iterando os pixels da amostra e colocando-os na camada de entrada da rede neural. A fun\u00e7\u00e3o <code>network.apply()</code> \u00e9 ent\u00e3o chamada para executar a rede neural na entrada.</p> <p>As fun\u00e7\u00f5es <code>preclassify_sample</code> e <code>classify_sample</code> retornam a primeira sa\u00edda da rede neural como um n\u00famero de ponto flutuante. Esta sa\u00edda \u00e9 provavelmente uma pontua\u00e7\u00e3o de confian\u00e7a que indica a probabilidade de a amostra conter uma bola.</p>"},{"location":"robotica/sensoriamento/ball-detection/#position_sample","title":"position_sample","text":"<p>A fun\u00e7\u00e3o <code>position_sample</code>, por outro lado, retorna um Circle que representa a posi\u00e7\u00e3o e o tamanho da bola na amostra. O centro e o raio do c\u00edrculo s\u00e3o determinados pelas tr\u00eas primeiras sa\u00eddas da rede neural.</p>"},{"location":"robotica/sensoriamento/ball-detection/#sample_grayscale","title":"sample_grayscale","text":"<p>A fun\u00e7\u00e3o <code>sample_grayscale</code> usa uma refer\u00eancia a YCbCr422Image e a Circle como argumentos. O Circle representa uma bola candidata dentro da imagem. A fun\u00e7\u00e3o cria uma amostra em tons de cinza da imagem dentro do c\u00edrculo candidato. Isso \u00e9 feito iterando os pixels dentro do c\u00edrculo, convertendo cada pixel em escala de cinza e colocando o valor da escala de cinza na amostra. A amostra \u00e9 ent\u00e3o devolvida.</p>"},{"location":"robotica/sensoriamento/ball-detection/#evaluate_candidates_1","title":"evaluate_candidates","text":"<p>A fun\u00e7\u00e3o <code>evaluate_candidates</code> pega uma lista de poss\u00edveis candidatos \u00e0 bola (representados como c\u00edrculos), uma imagem e um conjunto de redes neurais. Ele avalia cada candidato ampliando o c\u00edrculo do candidato, amostrando os valores da escala de cinza da imagem dentro desse c\u00edrculo e, em seguida, alimentando essa amostra em duas redes neurais: um <code>preclassifier</code> e um <code>classifier</code>. O <code>preclassifier</code> \u00e9 usado para eliminar rapidamente candidatos improv\u00e1veis, enquanto o <code>classifier</code> \u00e9 usado para uma avalia\u00e7\u00e3o mais detalhada. Se a confian\u00e7a do <code>classifier</code> estiver acima de um determinado limite, o c\u00edrculo do candidato \u00e9 corrigido utilizando uma terceira rede neural, o posicionador.</p>"},{"location":"robotica/sensoriamento/ball-detection/#bounding_box_patch_intersection","title":"bounding_box_patch_intersection","text":"<p>A fun\u00e7\u00e3o <code>bounding_box_patch_intersection</code> calcula a \u00e1rea de intersec\u00e7\u00e3o entre as caixas delimitadoras de dois c\u00edrculos (o c\u00edrculo candidato e um c\u00edrculo candidato de patch). Isso \u00e9 usado para determinar quanta sobreposi\u00e7\u00e3o existe entre os dois c\u00edrculos.</p>"},{"location":"robotica/sensoriamento/ball-detection/#image_containment","title":"image_containment","text":"<p>A fun\u00e7\u00e3o <code>image_containment</code> calcula quanto de um c\u00edrculo est\u00e1 contido na imagem. Isto \u00e9 feito criando um ret\u00e2ngulo que representa a imagem, calculando a \u00e1rea de interse\u00e7\u00e3o entre a caixa delimitadora do c\u00edrculo e o ret\u00e2ngulo da imagem e, em seguida, dividindo-a pela \u00e1rea da caixa delimitadora do c\u00edrculo.</p>"},{"location":"robotica/sensoriamento/ball-detection/#calculate_ball_merge_factor_1","title":"calculate_ball_merge_factor","text":"<p>A fun\u00e7\u00e3o <code>calculate_ball_merge_factor</code> calcula um fator de mesclagem para uma bola. Isso \u00e9 feito aumentando a confian\u00e7a do classificador, a proximidade da corre\u00e7\u00e3o (qu\u00e3o pr\u00f3ximo o c\u00edrculo corrigido est\u00e1 do c\u00edrculo candidato) e a conten\u00e7\u00e3o da imagem para certas pot\u00eancias e depois multiplicando-as.</p>"},{"location":"robotica/sensoriamento/ball-detection/#merge_balls","title":"merge_balls","text":"<p>A fun\u00e7\u00e3o <code>merge_balls</code> mescla uma lista de bolas em uma \u00fanica bola. Isto \u00e9 feito calculando uma m\u00e9dia ponderada dos centros e raios das bolas, onde os pesos s\u00e3o os pesos mesclados das bolas.</p>"},{"location":"robotica/sensoriamento/ball-detection/#cluster_balls_1","title":"cluster_balls","text":"<p>A fun\u00e7\u00e3o <code>cluster_balls</code> agrupa uma lista de bolas com base na proximidade umas das outras. Isso \u00e9 feito iterando sobre as bolas e, para cada bola, encontrando um cluster cujo centro esteja a uma certa dist\u00e2ncia da bola. Se tal agrupamento for encontrado, a bola \u00e9 adicionada ao agrupamento e o c\u00edrculo do agrupamento \u00e9 atualizado fundindo-o com o c\u00edrculo da bola. Se tal cluster n\u00e3o for encontrado, um novo cluster \u00e9 criado tendo a bola como \u00fanico membro.</p>"},{"location":"robotica/sensoriamento/ball-detection/#project_balls_to_ground_1","title":"project_balls_to_ground","text":"<p>Finalmente, a fun\u00e7\u00e3o <code>project_balls_to_ground</code> projeta uma lista de grupos de bolas no ch\u00e3o. Isso \u00e9 feito convertendo as coordenadas de pixel do centro do cluster em coordenadas terrestres usando uma matriz de c\u00e2mera. Se esta convers\u00e3o for bem-sucedida, uma nova bola \u00e9 criada com as coordenadas do solo como posi\u00e7\u00e3o e o c\u00edrculo do cluster como localiza\u00e7\u00e3o da imagem. A fun\u00e7\u00e3o retorna uma lista dessas bolas.</p>"},{"location":"robotica/sensoriamento/filtragem/","title":"Filtragem","text":"<p>TODO</p>"},{"location":"robotica/sensoriamento/visao/","title":"Vis\u00e3o","text":"<p>Esta se\u00e7\u00e3o est\u00e1 em desenvolvimento</p> <p>A vis\u00e3o da Rinobot-Jaguar atualmente utiliza uma Rede Neural Convolucional (CNN) para identificar a bola, e no futuro, rob\u00f4s advers\u00e1rios. A CNN utilizada \u00e9 a Tiny YOLOv3, uma vers\u00e3o reduzida do YOLO (You Only Look Once) destinada a dispositivos embarcados.</p> <p>O treinamento \u00e9 feito em computador para melhor utilizar recursos de processamento, como GPU, e o modelo \u00e9 compilado em uma matriz de pesos </p>"},{"location":"robotica/sensoriamento/visao/#treinamento","title":"Treinamento","text":"<p>Para o treinamento do modelo, utilizamos o Darknet, uma framework que direciona a YOLO para detec\u00e7\u00e3o de objetos. Como fonte de dados, utilizamos o ImageTagger, um banco de imagens retiradas de jogos da Robocup e German Open e disponibilizado gratuitamente. Mais precisamente utilizamos o dataset da NaoDevils, de Dortmund.</p>"},{"location":"robotica/sensoriamento/visao/#deteccao-de-marcas","title":"Detec\u00e7\u00e3o de Marcas","text":"<p>EM DESENVOLVIMENTO</p>"},{"location":"robotica/sensoriamento/visao/#deteccao-de-robos","title":"Detec\u00e7\u00e3o de Rob\u00f4s","text":"<p>EM DESENVOLVIMENTO</p>"},{"location":"robotica/sensoriamento/visao/#haar-cascade","title":"Haar Cascade","text":"<p>NO FUTURO PLANEJAMOS UTILIZAR O HAAR CASCADE NOVAMENTE, PARA SELE\u00c7\u00c3O DE CANDIDATOS</p> <p>TODO: Adicionar mais conte\u00fado</p>"},{"location":"sistema-operacional/","title":"Sobre","text":"<p>Esta se\u00e7\u00e3o detalha como \u00e9 feito e como funciona o sistema operacional do NAO. Aqui, voc\u00ea vai encontrar informa\u00e7\u00f5es sobre como o sistema \u00e9 organizado, como ele \u00e9 atualizado e como ele \u00e9 configurado.</p> <p>TODO: Detalhar e HULA</p>"},{"location":"sistema-operacional/#capitulos","title":"Cap\u00edtulos","text":"<ul> <li>Particionamento: Explica como o sistema operacional do NAO \u00e9 particionado no disco.  </li> <li>Diret\u00f3rio Home: Apresenta o diret\u00f3rio home do NAO, como ele \u00e9 organizado e como afeta o funcionamento.  </li> <li>Linux: Detalhes e informa\u00e7\u00f5es sobre o sistema Linux utilizado no NAO.  </li> <li>WiFi: Detalhes da conex\u00e3o wireless, como configurar e conectar o NAO a uma rede WiFi.  </li> <li>HULA: O que \u00e9 e como funciona o HULA, uma das interfaces de hardware.  </li> </ul>"},{"location":"sistema-operacional/home-dir/","title":"Diret\u00f3rio Home","text":"<p>O diret\u00f3rio Home (<code>/home/nao</code>) \u00e9 sobreposto com uma montagem na parti\u00e7\u00e3o <code>/data</code>.</p> <p>Quando flashando para o rob\u00f4 e atualizando o bin\u00e1rio do HULK, a estrutura do diret\u00f3rio home tem esta apar\u00eancia:</p> <pre><code>.\n|-- hulk\n|   |-- bin\n|   |   `-- hulk\n|   |-- etc\n|   |   |-- parameters\n|   |   |   `-- *.json\n|   |   |-- motions\n|   |   |   `-- *.motion2\n|   |   |-- neural_networks\n|   |   |   `-- *.hdf5\n|   |   |-- poses\n|   |   |   `-- *.pose\n|   |   `-- sounds\n|   |       `-- *.ogg\n|   `-- logs\n|       |-- hulk-1667906932.err\n|       |-- hulk-1667906932.out\n|       |-- hulk.err -&gt; /home/nao/hulk/logs/hulk-1667906932.err\n|       `-- hulk.out -&gt; /home/nao/hulk/logs/hulk-1667906932.out\n`-- robocup.conf\n</code></pre> <p>O arquivo <code>./robocup.conf</code> \u00e9 necess\u00e1rio para iniciar o servi\u00e7o do LoLA no modo Robocupper. Todos os arquivos relacionados com o servi\u00e7o e bin\u00e1rios HULK s\u00e3o armazenados no subdiret\u00f3rio <code>hulk</code> e espelha a estrutura de arquivos de desenvolvimento.</p>"},{"location":"sistema-operacional/hula/","title":"HUlks Level Abstraction (HULA)","text":"<p>O HULA \u00e9 uma camada de abstra\u00e7\u00e3o que conecta o LoLA (Low Level Abstraction) padr\u00e3o da Aldebaran e serve de interface para nossas aplica\u00e7\u00f5es. Diferente do LoLA, o HULA suporta m\u00faltiplos clients simult\u00e2neos.</p> <p></p>"},{"location":"sistema-operacional/hula/#no-nao","title":"No NAO","text":"<p>No NAO, o systemd gerencia o <code>hula.service</code>. Ele pode ser iniciado, parado e reiniciado com os comandos padr\u00e3o do systemd:</p> <pre><code>systemctl start hula\nsystemctl stop hula\nsystemctl restart hula\n</code></pre>"},{"location":"sistema-operacional/hula/#buildar","title":"Buildar","text":"<p>Embora j\u00e1 venha compilada na imagem, caso seja necess\u00e1rio, para buildar o HULA:</p> <ol> <li>Forne\u00e7a a source do SDK com o comando <code>. naosdk/&lt;version&gt;/environment-setup-corei7-64-aldebaran-linux</code>. Certifique-se de usar uma shell padr\u00e3o POSIX, como o bash.  </li> <li>Rode <code>cargo build --manifest-path tools/hula/Cargo.toml</code> para compilar o bin\u00e1rio.  </li> <li>Copie o bin\u00e1rio compilado da pasta <code>hula/target</code> para o NAO com o comando <code>scp &lt;imagem&gt; &lt;endereco ssh do nao:home/&gt;</code>.  </li> <li>Conecte no NAO via SSH: <code>ssh nao@&lt;endereco ssh do nao&gt;</code> ou <code>pepsi shell &lt;endereco&gt;</code>.  </li> <li>Pare o servi\u00e7o HULA que provavelmente est\u00e1 rodando: <code>systemctl stop hula</code>.</li> <li>Execute o bin\u00e1rio copiado: <code>./hula</code>.  </li> <li>Seja feliz.  </li> </ol>"},{"location":"sistema-operacional/linux/","title":"Linux","text":"<p>O NAO utiliza o kernel do Linux vers\u00e3o 5.4 para processadores Intel.</p> <p>A maior parte da configura\u00e7\u00e3o do kernel \u00e9 feitar pela camada <code>meta-intel</code> do Yocto, modifica\u00e7\u00f5es espec\u00edficas para o NAO s\u00e3o feitas pela camada <code>meta-nao</code> e consistem de atualiza\u00e7\u00f5es e m\u00f3dulos para o kernel para comunica\u00e7\u00e3o com a placa do peito.</p>"},{"location":"sistema-operacional/particionamento/","title":"Particionamento","text":"<p>O Nao usa um \u00fanico dispositivo de armazenamento flash para fins de armazenamento principal. Depois de fazer o flash corretamente com o HULKsOS, esse dispositivo fica reconhecido como <code>/dev/mmcblk1</code>. O dispositivo conta com 4 parti\u00e7\u00f5es diferentes: <pre><code>NOME           TAMANHO     PONTO DE MONTAGEM\nmmcblk1p1       29.1G\n|- mmcblk1p1    128M      /media/internal\n|- mmcblk1p2    64M       \n|- mmcblk1p3    3.8G      /\n|- mmcblk1p4    25.1G     /data\n</code></pre></p>"},{"location":"sistema-operacional/particionamento/#mmcblk1p1-softbank-partition","title":"<code>mmcblk1p1</code>: Softbank Partition","text":"<p>A primeira parti\u00e7\u00e3o \u00e9 chamada de 'internal' e \u00e9 usada pelos bin\u00e1rios da Softbank durante o flash. A parti\u00e7\u00e3o \u00e9 montada por padr\u00e3o em <code>/media/internal</code> e \u00e9 necess\u00e1ria para interface com o LoLA ou HAL. Durante utiliza\u00e7\u00e3o normal, essa parti\u00e7\u00e3o n\u00e3o \u00e9 acessada pelos bin\u00e1rios do Tamboerijn.</p> <p>A Softbank utiliza essa parti\u00e7\u00e3o para armazenar informa\u00e7\u00f5es gerais, como IDs. Por exemplo, o script <code>/opt/aldebaran/head_id</code> usa o arquivo <code>/media/internal/DeviceHeadInternalGeode.xml</code> para recolher o ID da cabe\u00e7a.</p>"},{"location":"sistema-operacional/particionamento/#mmcblk1p2-efi-partition","title":"<code>mmcblk1p2</code>: EFI Partition","text":"<p>A segunda parti\u00e7\u00e3o \u00e9 a de EFI boot, e n\u00e3o \u00e9 montada por padr\u00e3o. Para acessar ela, e os arquivos de EFI, monte a parti\u00e7\u00e3o: <pre><code>    # No shell do NAO\n    sudo su\n    mount /dev/mmblk1p2 /mnt/\n    # Arquivos de EFI est\u00e3o em /mnt/\n</code></pre></p>"},{"location":"sistema-operacional/particionamento/#mmcblk1p3-root-partition","title":"<code>mmcblk1p3</code>: Root Partition","text":"<p>A terceira parti\u00e7\u00e3o \u00e9 o root. Ela \u00e9 criada e administrada pela configura\u00e7\u00e3o do Yocto e n\u00e3o deve ser alterada em runtime. Para modificar a parti\u00e7\u00e3o, \u00e9 necess\u00e1rio fazer as altera\u00e7\u00f5es necess\u00e1rias durante o processo de cria\u00e7\u00e3o da imagem e depois reflashar o sistema.</p>"},{"location":"sistema-operacional/particionamento/#mmcblk1p4-data-partition","title":"<code>mmcblk1p4</code>: Data Partition","text":"<p>A quarta parti\u00e7\u00e3o \u00e9 para armazenagem e dados do runtime. Ela \u00e9 montada em <code>/data</code> por padr\u00e3o.</p> <p>Quando iniciando o sistema pela primeira vez, as duas unidades de sistema <code>data-format</code> e <code>data-skeleton</code> s\u00e3o respons\u00e1veis por configurar a parti\u00e7\u00e3o e estrutura de diret\u00f3rios. A unidade <code>data-format</code> roda uma vez antes de montar a parti\u00e7\u00e3o para criar a \u00e1rvore de diret\u00f3rios, e depois se desabilita. A unidade <code>data-skeleton</code> roda toda vez que o sistema \u00e9 iniciado e garante o funcionamento da estrutura de diret\u00f3rios para outras montagens.</p>"},{"location":"sistema-operacional/wifi/","title":"WiFi","text":"<p>O WiFi \u00e9 fornecido por um chip Qualcomm Atheros AR9462, que \u00e9 um chip de rede sem fio de banda dupla 802.11ac. O WiFi \u00e9 configurado via iNet Wireless Daemon (iwd).</p>"},{"location":"sistema-operacional/wifi/#configuracao-iwd","title":"Configura\u00e7\u00e3o <code>iwd</code>","text":"<p>O servi\u00e7o iwd pode ser configurado manualmente usando a ferramentos interface de comando <code>iwctl</code>. Para mudan\u00e7as persistentes, o iwd guarda arquvivos <code>*psk</code> para cada SSID conhecido em <code>/var/lib/iwd/</code>. A distribui\u00e7\u00e3o Yocto  instala esses arquivos <code>*psk</code> para as redes de SSIDs de SPL_A a SPL_F.</p> <pre><code>    [Security]\n    Passphrase=Nao1237\n\n    [Settings]\n    AutoConnect=false\n</code></pre> <p>Conex\u00e3o automatica est\u00e1 desativada para prevenir que o NAO conecte \u00e0 rede do SPL sem necessidade, o que pode causar problemas durante partidas de outras equipes. Se o iwd foi designado para conectar na rede uma vez, ele tenta reconectar para o mesmo SSID at\u00e9 que o daemon seja instru\u00eddo a desconectar.</p> <p>O iwd tamb\u00e9m pode ser usado para configurar o IP e rodar DHCP. Esta op\u00e7\u00e3o \u00e9 chamada <code>Network Configuration</code> e desabilitada via <code>/etc/iwd/main.conf</code>. Configura\u00e7\u00e3o de IP \u00e9 feita pelo systemd-networkd.</p> <pre><code>    [General]\n    EnableNetworkConfiguration=false\n</code></pre>"},{"location":"sistema-operacional/wifi/#configuracao-de-ip","title":"Configura\u00e7\u00e3o de IP","text":"<p>O IP do NAO \u00e9 derivado do n\u00famero de ID dos rob\u00f4s como setado em <code>../config-projeto/imagem-sdk.md</code>. Para IPv6 ele segue o padr\u00e3o <code>10.{interface}.{time}.{nao}</code>. Por exemplo, para o rob\u00f4 13 da equipe Rinobot-Jaguar, o IPv6 para a interface wireless \u00e9 <code>10.0.47.13</code> e para cabeada <code>10.1.47.13</code>.   </p>"},{"location":"workflow/","title":"Sobre","text":"<p>Antes de ver os pontos mais importantes do nosso Workflow, \u00e9 preciso que voc\u00ea j\u00e1 tenha configurado seu ambiente de desenvolvimento. Para isso, siga os guias da parte de configura\u00e7\u00e3o do projeto.</p> <p>O Workflow \u00e9 o fluxo de a\u00e7\u00f5es necess\u00e1rios para desenvolver de forma eficiente e eficaz. Aqui, vamos abordar os pontos mais importantes para o desenvolvimento de software para o NAO no SPL.</p> <p>Cap\u00edtulos: - Compilar c\u00f3digo arbrit\u00e1rio em Rust para o NAO: Explica como compilar um c\u00f3digo qualquer em rust para o NAO usando a toolchain da HULKs - Competi\u00e7\u00e3o: Explica como configurar o ambiente e os NAOs para a competi\u00e7\u00e3o, como e o que fazer durante os jogos, e como fazer a manuten\u00e7\u00e3o no c\u00f3digo durante elas - Desenvolvimento: Explica como desenvolver um c\u00f3digo para o NAO, como testar e como fazer a manuten\u00e7\u00e3o do c\u00f3digo de forma eficiente</p>"},{"location":"workflow/competicao/","title":"Competi\u00e7\u00e3o","text":"<p>TODO</p>"},{"location":"workflow/compilar-hello-world/","title":"Quero compilar um c\u00f3digo qualquer em Rust pro NAO","text":"<p>Exemplo: quero rodar um \"Hello World\" no rob\u00f4, como fazer?</p>"},{"location":"workflow/compilar-hello-world/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Quando um c\u00f3digo \u00e9 compilado, usando, por exemplo, <code>cargo build</code>, \u00e9 basicamente gerado um arquivo bin\u00e1rio espec\u00edfico para a arquitetura do seu computador. Ou seja, caso voc\u00ea compile no seu computador muito provavelmente o bin\u00e1rio n\u00e3o vai rodar no rob\u00f4. Da mesma forma, caso voc\u00ea compile no seu computador muito provavelmente n\u00e3o vai rodar num computador com arquitetura x86 [^1].</p>"},{"location":"workflow/compilar-hello-world/#o-que-fazer-entao","title":"O que fazer ent\u00e3o?","text":"<p>Compila o c\u00f3digo no rob\u00f4 mesmo: Cross Compiling. Voc\u00ea compila o c\u00f3digo em uma m\u00e1quina para ser executado em outra (outro tipo de m\u00e1quina/arquitetura)!  </p>"},{"location":"workflow/compilar-hello-world/#mas-como-fazer-isso","title":"Mas como fazer isso?","text":"<p>No caso do sistema da HULKs, (o texto a seguir parte de muito achismo e interpreta\u00e7\u00e3o do que os membros da equipe alem\u00e3 explicaram em reuni\u00e3o com a gente) Ao usar o Yocto[^2] para gerar o sistema da HULKs (e posteriormente o nosso) \u00e9 tamb\u00e9m gerado alguns bin\u00e1rios para <code>cross</code> compilar o c\u00f3digo para o NAO. Esses bin\u00e1rios fazem parte da (cross)toolchain da HULKs. Dessa forma, podemos simplesmente usar esses bin\u00e1rios para compilar um c\u00f3digo arbitr\u00e1rio pro rob\u00f4!!</p>"},{"location":"workflow/compilar-hello-world/#entendi-mas-como-fazer-isso","title":"Entendi, mas como fazer isso?","text":"<p>Como eu falei na toolchain da HULKs tem ferramentas para compilar o c\u00f3digo espec\u00edfico pro rob\u00f4 (ao inv\u00e9s de compilar para arquitetura do seu pr\u00f3prio PC).  (esse meio do caminho eu entendi direito ainda, mas..) Basta usar o <code>cargo</code> (ferramenta de compila\u00e7\u00e3o do rust) que tem na toolchain. Agora eu tenho dois <code>cargo</code>s no meu computador, um que compila Rust normalmente, outro que compila especificamente pro NAO. Ent\u00e3o s\u00f3 usar esse segundo ao inv\u00e9s do primeiro quando eu for compilar pro rob\u00f4! Para isso eles (HULKs) desenvolveram um script de bash que configura o ambiente para usar essa vers\u00e3o do cargo (e demais coisinhas necess\u00e1rias para funcionar) quando voc\u00ea digitar <code>cargo build</code>.</p>"},{"location":"workflow/compilar-hello-world/#localizacao-do-script","title":"Localiza\u00e7\u00e3o do Script:","text":"<pre><code>~/.naosdk/7.1.0/environment-setup-corei7-64-aldebaran-linux\n# note que \"~\" \u00e9 o mesmo que \"/home/seu_nome\"\n# note tamb\u00e9m que talvez o caminho mude, esse funciona para a vers\u00e3o 7.1.0, mas  muito provavelmente N\u00c3O \u00e9 seu caso\n</code></pre>"},{"location":"workflow/compilar-hello-world/#nao-achei-a-pasta-naosdk-no-meu-computador","title":"N\u00e3o achei a pasta <code>.naosdk</code> no meu computador","text":"<p>Instala o c\u00f3digo da HULKs (usando o pepsi) no seu computador primeiro depois volta aqui. Note que talvez seja melhor usar o NOSSO c\u00f3digo ao inv\u00e9s do da HULKs. Clonar o Rinobot-Team/Tamboerijn ao inv\u00e9s do HULKs/hulk. Obs: pra instalar basta dar um <code>./pepsi</code> na pasta do reposit\u00f3rio da HULKs. </p> <ol> <li>Instala o rust: https://rustup.rs/</li> <li>Instala as dependencias do c\u00f3digo da HULKs: <code>sudo apt install -y git git-lfs clang python3 zstd xz-utils file rsync</code></li> <li><code>git clone https://github.com/HULKs/hulk</code></li> <li><code>cd\u00a0hulk</code></li> <li><code>./pepsi</code></li> </ol>"},{"location":"workflow/compilar-hello-world/#execucao-do-script","title":"Execu\u00e7\u00e3o do Script:","text":"<p>Antes de executar, uma ressalva, esse script altera v\u00e1rias vari\u00e1veis de ambiente para fazer funcionar o c\u00f3digo. Ent\u00e3o vale entrar em outra sess\u00e3o[^3] de bash antes para n\u00e3o \"contaminar\" a atual. Para rodar o script execute:</p> <pre><code>bash\nsource ~/.naosdk/7.1.0/environment-setup-corei7-64-aldebaran-linux \n# troque o argumento ~/.naosdk/7.1.0/environment-setup-corei7-64-aldebaran-linux  pelo caminho desse arquivo em quest\u00e3o no seu computador!!\n</code></pre>"},{"location":"workflow/compilar-hello-world/#como-verificar-se-funcionou","title":"Como verificar se funcionou","text":"<p>O comando <code>type</code> mostra como um comando seria interpretado pelo shell se fosse chamado. De forma parecida o comando <code>which</code> procura no PATH do sistema por que programa \u00e9 chamado ao digitar tal comando.</p>"},{"location":"workflow/compilar-hello-world/#portanto-para-verificar-se-o-script-rodou-podemos","title":"Portanto para verificar se o script rodou, podemos:","text":"<pre><code>type cargo\n# ou which cargo\n# ou type rustc\n</code></pre>"},{"location":"workflow/compilar-hello-world/#como-rodar-um-codigo-entao","title":"Como rodar um c\u00f3digo ent\u00e3o","text":"<p>Agora como o <code>cargo</code> (e demais programas) apontam para essa vers\u00e3o expec\u00edfica para compilar pro NAO, podemos simplesmente criar e compilar um projeto em Rust:</p>"},{"location":"workflow/compilar-hello-world/#para-compilar","title":"Para compilar","text":"<pre><code>cargo new teste &amp;&amp;\ncd teste &amp;&amp;\ncargo build\n</code></pre>"},{"location":"workflow/compilar-hello-world/#para-passar-e-rodar-no-robo","title":"Para passar e rodar no rob\u00f4","text":""},{"location":"workflow/compilar-hello-world/#introducao_1","title":"Introdu\u00e7\u00e3o","text":"<p>Existe varias maneiras de acessar outro computador remotamente. Uma delas \u00e9 o ssh que nos permite de forma segura abrir um terminal como um usu\u00e1rio numa outra m\u00e1quina. </p>"},{"location":"workflow/compilar-hello-world/#usando-o-ssh","title":"Usando o ssh","text":"<p>Para usar o ssh de forma simples basta passar o usu\u00e1rio e o endere\u00e7o de IP da m\u00e1quina que voc\u00ea quer acessar (como se fosse aquele usu\u00e1rio). Exemplo:</p> <pre><code>ssh nao@192.18.0.100\n# usu\u00e1rio: nao\n# endere\u00e7o IP do rob\u00f4: 192.168.0.100\n</code></pre> <p>Pronto voc\u00ea est\u00e1 acessando o NAO. Voc\u00ea pode fazer basicamente TUDO no rob\u00f4 a partir da\u00ed. Talvez desse menos trabalho se tivesse uma interface gr\u00e1fica, mas poxa, muito chique, n\u00e9?</p>"},{"location":"workflow/compilar-hello-world/#como-enviarreceber-arquivos-via-ssh","title":"Como enviar/receber arquivos via ssh","text":"<p>O comando scp \u00e9 a mistura de ssh com cp<sub>(copiar)</sub>. Ou seja, copia via ssh.</p>"},{"location":"workflow/compilar-hello-world/#para-usar-esse-comando","title":"Para usar esse comando:","text":"<p>scp usu\u00e1rio@m\u00e1quina:local/de/destino</p>"},{"location":"workflow/compilar-hello-world/#exemplo","title":"Exemplo:","text":"<pre><code>scp nome_do_arquivo nao@192.168.0.100:/home/nao\n# arquivo: nome_do_arquivo\n# usu\u00e1rio no rob\u00f4: nao\n# IP do rob\u00f4: 192.186.0.100\n# local de destino no rob\u00f4: /home/nao (representado pelo \"~\" dentro do rob\u00f4)\n</code></pre>"},{"location":"workflow/compilar-hello-world/#para-passar-o-codigo-compilado-pro-robo-entao","title":"Para passar o c\u00f3digo compilado pro rob\u00f4 ent\u00e3o:","text":"<pre><code>scp ~/teste/target/x86_64-aldebaran-linux-gnu/debug/teste\n</code></pre> <p>sendo \"teste\" o nome da pasta/projeto e \"teste\" por padr\u00e3o ent\u00e3o o nome do execut\u00e1vel note que os bin\u00e1rios ficam na pasta target quando compilados via 'cargo'</p> <p></p>"},{"location":"workflow/compilar-hello-world/#todo","title":"TODO:","text":"<ul> <li>[X] E se eu n\u00e3o tiver nem essa pasta .naosdk? Instala o codigo da HULKs ./pepsi</li> <li>[X] Para checar se funcionou</li> <li>[X] Como compilar ent\u00e3o?</li> <li>[ ] E compilar biblioteca?</li> </ul>"},{"location":"workflow/compilar-hello-world/#notes","title":"Notes","text":"<p>[^1]:      Veja mais aqui [^2]:      Yocto \u00e9 um projeto que permite criar distribui\u00e7\u00f5es linux customizadas independente do hardware. Pensada justamente para sistemas embarcados com os mais diferentes hardwares. Mais informa\u00e7\u00f5es aqui [^3]:       N\u00e3o \u00e9 uma sess\u00e3o, \u00e9 mais uma inst\u00e2ncia  </p>"},{"location":"workflow/desenvolvimento/","title":"Desenvolvimento","text":"<p>TODO</p>"},{"location":"workflow/versionamento/","title":"Versionamento","text":"<p>Como o pr\u00f3prio nome sugere, o versionamento \u00e9 o controle de vers\u00f5es de um software. Para isso, utilizamos git e github para hospedar.</p>"},{"location":"workflow/versionamento/#git","title":"Git","text":"<p>Considerando que voc\u00ea j\u00e1 tenha feito o setup do git, criado uma conta no github e configurado o ssh, vamos ao que interessa.</p>"},{"location":"workflow/versionamento/#convencoes-de-versionamento-do-spl","title":"Conven\u00e7\u00f5es de versionamento do SPL:","text":"<ul> <li> <p>Branches:</p> <ul> <li><code>main</code>: branch principal, onde o c\u00f3digo est\u00e1vel \u00e9 mantido.</li> <li><code>dev</code>: branch de desenvolvimento, onde o c\u00f3digo em desenvolvimento \u00e9 mantido. \u00c9 ideal que nela tenha c\u00f3digo que pelo menos compile.</li> <li><code>dev-local</code>: branch de desenvolvimento local do desenvolvedor, onde o c\u00f3digo que voc\u00ea est\u00e1 desenvolvendo no momento \u00e9 mantido. Por favor, n\u00e3o fa\u00e7a push nela.</li> <li><code>release</code>: branch em que o c\u00f3digo est\u00e1vel \u00e9 mantido para ser lan\u00e7ado. As releases acontecem no inicio de cada campeonato e \u00e9 o c\u00f3digo com que competiremos, e que ser\u00e1 avaliado pela RoboCup.</li> </ul> </li> <li> <p>Nomenclatura de commits:</p> <ul> <li><code>feat</code>: para novas features. Ex: <code>feat: Adiciona c\u00f3digo para dar mortal para tr\u00e1s</code>.</li> <li><code>fix</code>: para corre\u00e7\u00e3o de bugs. Ex: <code>fix: Corrige bug que fazia o rob\u00f4 tentar exterminar a humanidade</code>.</li> <li><code>refactor</code>: para refatora\u00e7\u00e3o de c\u00f3digo. Ex: <code>refactor: Refatora c\u00f3digo para renomear a fun\u00e7\u00e3o anda() para nao_anda()</code>.</li> <li><code>issue#</code>: para commits relacionados a issues. Ex: <code>issue#1: Adiciona c\u00f3digo para dar mortal para tr\u00e1s</code>. </li> <li><code>release</code>: para commits relacionados a releases. Ex: <code>release: C\u00f3digo para ganhar dos alem\u00e3o</code>.</li> </ul> </li> </ul> <p>Obs: Sempre que for fazer um commit, tente fazer um commit at\u00f4mico, ou seja, um commit para cada feature, bug ou refatora\u00e7\u00e3o. Isso facilita a leitura do hist\u00f3rico de commits.</p>"},{"location":"workflow/versionamento/#fluxo-de-trabalho","title":"Fluxo de trabalho:","text":"<p>\u00c9 de bom tom que sempre inicie um novo fluxo de trabalho com um <code>git pull</code> para garantir que voc\u00ea est\u00e1 trabalhando com a vers\u00e3o mais atualizada do c\u00f3digo.</p> <p>Caso esteja trabalhando em uma nova feature e precise criar diferentes branches locais, fa\u00e7a. Mas s\u00f3 de push na branch <code>dev</code> quando o c\u00f3digo ao menos compilar. Para criar uma nova branch local e mudar para ela: <pre><code>    git switch -c dev-local-agora-vai-2\n</code></pre> Depois que fizer as altera\u00e7\u00f5es necess\u00e1rias, adicione, commit e mude para a branch <code>dev-local</code>: <pre><code>    git add --all\n    git commit -m \"Funciona!!!\"\n    git switch dev-local\n    git merge dev-local-agora-vai-2\n</code></pre></p> <p>Para dar push em um c\u00f3digo em desenvolvimento, que compila, de merge na branch <code>dev</code> e d\u00ea push nela:  <pre><code>    # Na branch dev-local\n    git add --all\n    git commit -m \"feat: Adiciona c\u00f3digo para ensinar o NAO a dirigir escavadeira\"\n    git switch dev\n    git merge dev-local\n    git push\n</code></pre></p> <p>Caso esta feature esteja pronta para ser lan\u00e7ada, fa\u00e7a o merge na branch <code>main</code> e d\u00ea push nela: <pre><code>    # Na branch dev\n    git add --all\n    git commit -m \"fix: Corrige bug que fazia o NAO dirigir escavadeira em dire\u00e7\u00e3o ao pr\u00e9dio da Receita Federal\"\n    git switch main\n    git merge dev\n    git push\n</code></pre></p> <p>Caso esta feature esteja pronta para ser lan\u00e7ada, fa\u00e7a o merge na branch <code>release</code>, crie uma tag e d\u00ea push nela: <pre><code>    # Na branch main\n    git add --all\n    git commit -m \"release: C\u00f3digo para ganhar dos alem\u00e3o\"\n    git switch release\n    git merge main\n    git tag -a v1.0 -m \"Release Robocup24 1.0\"\n    git push\n</code></pre> Depois disso, v\u00e1 no github e crie uma release com a tag que voc\u00ea acabou de criar. </p>"},{"location":"workflow/versionamento/#conflitos","title":"Conflitos","text":"<p>Caso voc\u00ea tenha conflitos ao dar merge em uma branch, o git vai te avisar. Para resolver, abra o arquivo que est\u00e1 com conflito e resolva manualmente. Depois, adicione, commit e d\u00ea push. Caso n\u00e3o consiga resolver, pe\u00e7a para o Gerente.</p>"}]}